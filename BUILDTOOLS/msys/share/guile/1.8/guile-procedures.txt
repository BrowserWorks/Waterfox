This is guile-procedures.txt, produced by makeinfo version 4.13 from
guile-procedures.texi.

acons

 -- Scheme Procedure: acons key value alist
     Add a new key-value pair to ALIST.  A new pair is created whose
     car is KEY and whose cdr is VALUE, and the pair is consed onto
     ALIST, and the new list is returned.  This function is _not_
     destructive; ALIST is not modified.

   sloppy-assq

 -- Scheme Procedure: sloppy-assq key alist
     Behaves like `assq' but does not do any error checking.
     Recommended only for use in Guile internals.

   sloppy-assv

 -- Scheme Procedure: sloppy-assv key alist
     Behaves like `assv' but does not do any error checking.
     Recommended only for use in Guile internals.

   sloppy-assoc

 -- Scheme Procedure: sloppy-assoc key alist
     Behaves like `assoc' but does not do any error checking.
     Recommended only for use in Guile internals.

   assq

 -- Scheme Procedure: assq key alist
 -- Scheme Procedure: assv key alist
 -- Scheme Procedure: assoc key alist
     Fetch the entry in ALIST that is associated with KEY.  To decide
     whether the argument KEY matches a particular entry in ALIST,
     `assq' compares keys with `eq?', `assv' uses `eqv?' and `assoc'
     uses `equal?'.  If KEY cannot be found in ALIST (according to
     whichever equality predicate is in use), then return `#f'.  These
     functions return the entire alist entry found (i.e. both the key
     and the value).

   assv

 -- Scheme Procedure: assv key alist
     Behaves like `assq' but uses `eqv?' for key comparison.

   assoc

 -- Scheme Procedure: assoc key alist
     Behaves like `assq' but uses `equal?' for key comparison.

   assq-ref

 -- Scheme Procedure: assq-ref alist key
 -- Scheme Procedure: assv-ref alist key
 -- Scheme Procedure: assoc-ref alist key
     Like `assq', `assv' and `assoc', except that only the value
     associated with KEY in ALIST is returned.  These functions are
     equivalent to

          (let ((ent (ASSOCIATOR KEY ALIST)))
            (and ent (cdr ent)))

     where ASSOCIATOR is one of `assq', `assv' or `assoc'.

   assv-ref

 -- Scheme Procedure: assv-ref alist key
     Behaves like `assq-ref' but uses `eqv?' for key comparison.

   assoc-ref

 -- Scheme Procedure: assoc-ref alist key
     Behaves like `assq-ref' but uses `equal?' for key comparison.

   assq-set!

 -- Scheme Procedure: assq-set! alist key val
 -- Scheme Procedure: assv-set! alist key value
 -- Scheme Procedure: assoc-set! alist key value
     Reassociate KEY in ALIST with VALUE: find any existing ALIST entry
     for KEY and associate it with the new VALUE.  If ALIST does not
     contain an entry for KEY, add a new one.  Return the (possibly
     new) alist.

     These functions do not attempt to verify the structure of ALIST,
     and so may cause unusual results if passed an object that is not an
     association list.

   assv-set!

 -- Scheme Procedure: assv-set! alist key val
     Behaves like `assq-set!' but uses `eqv?' for key comparison.

   assoc-set!

 -- Scheme Procedure: assoc-set! alist key val
     Behaves like `assq-set!' but uses `equal?' for key comparison.

   assq-remove!

 -- Scheme Procedure: assq-remove! alist key
 -- Scheme Procedure: assv-remove! alist key
 -- Scheme Procedure: assoc-remove! alist key
     Delete the first entry in ALIST associated with KEY, and return
     the resulting alist.

   assv-remove!

 -- Scheme Procedure: assv-remove! alist key
     Behaves like `assq-remove!' but uses `eqv?' for key comparison.

   assoc-remove!

 -- Scheme Procedure: assoc-remove! alist key
     Behaves like `assq-remove!' but uses `equal?' for key comparison.

   make-arbiter

 -- Scheme Procedure: make-arbiter name
     Return an arbiter object, initially unlocked.  Currently NAME is
     only used for diagnostic output.

   try-arbiter

 -- Scheme Procedure: try-arbiter arb
     If ARB is unlocked, then lock it and return `#t'.  If ARB is
     already locked, then do nothing and return `#f'.

   release-arbiter

 -- Scheme Procedure: release-arbiter arb
     If ARB is locked, then unlock it and return `#t'.  If ARB is
     already unlocked, then do nothing and return `#f'.

     Typical usage is for the thread which locked an arbiter to later
     release it, but that's not required, any thread can release it.

   async

 -- Scheme Procedure: async thunk
     Create a new async for the procedure THUNK.

   async-mark

 -- Scheme Procedure: async-mark a
     Mark the async A for future execution.

   run-asyncs

 -- Scheme Procedure: run-asyncs list_of_a
     Execute all thunks from the asyncs of the list LIST_OF_A.

   system-async

 -- Scheme Procedure: system-async thunk
     This function is deprecated.  You can use THUNK directly instead
     of explicitly creating an async object.


   system-async-mark

 -- Scheme Procedure: system-async-mark proc [thread]
     Mark PROC (a procedure with zero arguments) for future execution
     in THREAD.  If PROC has already been marked for THREAD but has not
     been executed yet, this call has no effect.  If THREAD is omitted,
     the thread that called `system-async-mark' is used.

     This procedure is not safe to be called from C signal handlers.
     Use `scm_sigaction' or `scm_sigaction_for_thread' to install
     signal handlers.

   noop

 -- Scheme Procedure: noop . args
     Do nothing.  When called without arguments, return `#f', otherwise
     return the first argument.

   unmask-signals

 -- Scheme Procedure: unmask-signals
     Unmask signals. The returned value is not specified.

   mask-signals

 -- Scheme Procedure: mask-signals
     Mask signals. The returned value is not specified.

   call-with-blocked-asyncs

 -- Scheme Procedure: call-with-blocked-asyncs proc
     Call PROC with no arguments and block the execution of system
     asyncs by one level for the current thread while it is running.
     Return the value returned by PROC.


   call-with-unblocked-asyncs

 -- Scheme Procedure: call-with-unblocked-asyncs proc
     Call PROC with no arguments and unblock the execution of system
     asyncs by one level for the current thread while it is running.
     Return the value returned by PROC.


   display-error

 -- Scheme Procedure: display-error stack port subr message args rest
     Display an error message to the output port PORT.  STACK is the
     saved stack for the error, SUBR is the name of the procedure in
     which the error occurred and MESSAGE is the actual error message,
     which may contain formatting instructions. These will format the
     arguments in the list ARGS accordingly.  REST is currently ignored.

   display-application

 -- Scheme Procedure: display-application frame [port [indent]]
     Display a procedure application FRAME to the output port PORT.
     INDENT specifies the indentation of the output.

   display-backtrace

 -- Scheme Procedure: display-backtrace stack port [first [depth
          [highlights]]]
     Display a backtrace to the output port PORT. STACK is the stack to
     take the backtrace from, FIRST specifies where in the stack to
     start and DEPTH how much frames to display. Both FIRST and DEPTH
     can be `#f', which means that default values will be used.  When
     HIGHLIGHTS is given, it should be a list and all members of it are
     highligthed in the backtrace.

   backtrace

 -- Scheme Procedure: backtrace [highlights]
     Display a backtrace of the stack saved by the last error to the
     current output port.  When HIGHLIGHTS is given, it should be a
     list and all members of it are highligthed in the backtrace.

   not

 -- Scheme Procedure: not x
     Return `#t' iff X is `#f', else return `#f'.

   boolean?

 -- Scheme Procedure: boolean? obj
     Return `#t' iff OBJ is either `#t' or `#f'.

   char?

 -- Scheme Procedure: char? x
     Return `#t' iff X is a character, else `#f'.

   char=?

 -- Scheme Procedure: char=? x y
     Return `#t' iff X is the same character as Y, else `#f'.

   char<?

 -- Scheme Procedure: char<? x y
     Return `#t' iff X is less than Y in the ASCII sequence, else `#f'.

   char<=?

 -- Scheme Procedure: char<=? x y
     Return `#t' iff X is less than or equal to Y in the ASCII
     sequence, else `#f'.

   char>?

 -- Scheme Procedure: char>? x y
     Return `#t' iff X is greater than Y in the ASCII sequence, else
     `#f'.

   char>=?

 -- Scheme Procedure: char>=? x y
     Return `#t' iff X is greater than or equal to Y in the ASCII
     sequence, else `#f'.

   char-ci=?

 -- Scheme Procedure: char-ci=? x y
     Return `#t' iff X is the same character as Y ignoring case, else
     `#f'.

   char-ci<?

 -- Scheme Procedure: char-ci<? x y
     Return `#t' iff X is less than Y in the ASCII sequence ignoring
     case, else `#f'.

   char-ci<=?

 -- Scheme Procedure: char-ci<=? x y
     Return `#t' iff X is less than or equal to Y in the ASCII sequence
     ignoring case, else `#f'.

   char-ci>?

 -- Scheme Procedure: char-ci>? x y
     Return `#t' iff X is greater than Y in the ASCII sequence ignoring
     case, else `#f'.

   char-ci>=?

 -- Scheme Procedure: char-ci>=? x y
     Return `#t' iff X is greater than or equal to Y in the ASCII
     sequence ignoring case, else `#f'.

   char-alphabetic?

 -- Scheme Procedure: char-alphabetic? chr
     Return `#t' iff CHR is alphabetic, else `#f'.


   char-numeric?

 -- Scheme Procedure: char-numeric? chr
     Return `#t' iff CHR is numeric, else `#f'.


   char-whitespace?

 -- Scheme Procedure: char-whitespace? chr
     Return `#t' iff CHR is whitespace, else `#f'.


   char-upper-case?

 -- Scheme Procedure: char-upper-case? chr
     Return `#t' iff CHR is uppercase, else `#f'.


   char-lower-case?

 -- Scheme Procedure: char-lower-case? chr
     Return `#t' iff CHR is lowercase, else `#f'.


   char-is-both?

 -- Scheme Procedure: char-is-both? chr
     Return `#t' iff CHR is either uppercase or lowercase, else `#f'.


   char->integer

 -- Scheme Procedure: char->integer chr
     Return the number corresponding to ordinal position of CHR in the
     ASCII sequence.

   integer->char

 -- Scheme Procedure: integer->char n
     Return the character at position N in the ASCII sequence.

   char-upcase

 -- Scheme Procedure: char-upcase chr
     Return the uppercase character version of CHR.

   char-downcase

 -- Scheme Procedure: char-downcase chr
     Return the lowercase character version of CHR.

   with-continuation-barrier

 -- Scheme Procedure: with-continuation-barrier proc
     Call PROC and return its result.  Do not allow the invocation of
     continuations that would leave or enter the dynamic extent of the
     call to `with-continuation-barrier'.  Such an attempt causes an
     error to be signaled.

     Throws (such as errors) that are not caught from within PROC are
     caught by `with-continuation-barrier'.  In that case, a short
     message is printed to the current error port and `#f' is returned.

     Thus, `with-continuation-barrier' returns exactly once.


   debug-options-interface

 -- Scheme Procedure: debug-options-interface [setting]
     Option interface for the debug options. Instead of using this
     procedure directly, use the procedures `debug-enable',
     `debug-disable', `debug-set!' and `debug-options'.

   with-traps

 -- Scheme Procedure: with-traps thunk
     Call THUNK with traps enabled.

   memoized?

 -- Scheme Procedure: memoized? obj
     Return `#t' if OBJ is memoized.

   unmemoize-expr

 -- Scheme Procedure: unmemoize-expr m
     Unmemoize the memoized expression M,

   memoized-environment

 -- Scheme Procedure: memoized-environment m
     Return the environment of the memoized expression M.

   procedure-name

 -- Scheme Procedure: procedure-name proc
     Return the name of the procedure PROC

   procedure-source

 -- Scheme Procedure: procedure-source proc
     Return the source of the procedure PROC.

   procedure-environment

 -- Scheme Procedure: procedure-environment proc
     Return the environment of the procedure PROC.

   local-eval

 -- Scheme Procedure: local-eval exp [env]
     Evaluate EXP in its environment.  If ENV is supplied, it is the
     environment in which to evaluate EXP.  Otherwise, EXP must be a
     memoized code object (in which case, its environment is implicit).

   debug-object?

 -- Scheme Procedure: debug-object? obj
     Return `#t' if OBJ is a debug object.

   issue-deprecation-warning

 -- Scheme Procedure: issue-deprecation-warning . msgs
     Output MSGS to `(current-error-port)' when this is the first call
     to `issue-deprecation-warning' with this specific MSGS.  Do
     nothing otherwise. The argument MSGS should be a list of strings;
     they are printed in turn, each one followed by a newline.

   include-deprecated-features

 -- Scheme Procedure: include-deprecated-features
     Return `#t' iff deprecated features should be included in public
     interfaces.

   substring-move-left!

 -- Scheme Procedure: substring-move-left!
     implemented by the C function "scm_substring_move_x"

   substring-move-right!

 -- Scheme Procedure: substring-move-right!
     implemented by the C function "scm_substring_move_x"

   c-registered-modules

 -- Scheme Procedure: c-registered-modules
     Return a list of the object code modules that have been imported
     into the current Guile process.  Each element of the list is a
     pair whose car is the name of the module, and whose cdr is the
     function handle for that module's initializer function.  The name
     is the string that has been passed to scm_register_module_xxx.

   c-clear-registered-modules

 -- Scheme Procedure: c-clear-registered-modules
     Destroy the list of modules registered with the current Guile
     process.  The return value is unspecified.  *Warning:* this
     function does not actually unlink or deallocate these modules, but
     only destroys the records of which modules have been loaded.  It
     should therefore be used only by module bookkeeping operations.

   close-all-ports-except

 -- Scheme Procedure: close-all-ports-except . ports
     [DEPRECATED] Close all open file ports used by the interpreter
     except for those supplied as arguments.  This procedure was
     intended to be used before an exec call to close file descriptors
     which are not needed in the new process.  However it has the
     undesirable side effect of flushing buffers, so it's deprecated.
     Use port-for-each instead.

   variable-set-name-hint!

 -- Scheme Procedure: variable-set-name-hint! var hint
     Do not use this function.

   builtin-variable

 -- Scheme Procedure: builtin-variable name
     Do not use this function.

   sloppy-memq

 -- Scheme Procedure: sloppy-memq x lst
     This procedure behaves like `memq', but does no type or error
     checking.  Its use is recommended only in writing Guile internals,
     not for high-level Scheme programs.

   sloppy-memv

 -- Scheme Procedure: sloppy-memv x lst
     This procedure behaves like `memv', but does no type or error
     checking.  Its use is recommended only in writing Guile internals,
     not for high-level Scheme programs.

   sloppy-member

 -- Scheme Procedure: sloppy-member x lst
     This procedure behaves like `member', but does no type or error
     checking.  Its use is recommended only in writing Guile internals,
     not for high-level Scheme programs.

   read-and-eval!

 -- Scheme Procedure: read-and-eval! [port]
     Read a form from PORT (standard input by default), and evaluate it
     (memoizing it in the process) in the top-level environment.  If no
     data is left to be read from PORT, an `end-of-file' error is
     signalled.

   string->obarray-symbol

 -- Scheme Procedure: string->obarray-symbol o s [softp]
     Intern a new symbol in OBARRAY, a symbol table, with name STRING.

     If OBARRAY is `#f', use the default system symbol table.  If
     OBARRAY is `#t', the symbol should not be interned in any symbol
     table; merely return the pair (SYMBOL . #<UNDEFINED>).

     The SOFT? argument determines whether new symbol table entries
     should be created when the specified symbol is not already present
     in OBARRAY.  If SOFT? is specified and is a true value, then new
     entries should not be added for symbols not already present in the
     table; instead, simply return `#f'.

   intern-symbol

 -- Scheme Procedure: intern-symbol o s
     Add a new symbol to OBARRAY with name STRING, bound to an
     unspecified initial value.  The symbol table is not modified if a
     symbol with this name is already present.

   unintern-symbol

 -- Scheme Procedure: unintern-symbol o s
     Remove the symbol with name STRING from OBARRAY.  This function
     returns `#t' if the symbol was present and `#f' otherwise.

   symbol-binding

 -- Scheme Procedure: symbol-binding o s
     Look up in OBARRAY the symbol whose name is STRING, and return the
     value to which it is bound.  If OBARRAY is `#f', use the global
     symbol table.  If STRING is not interned in OBARRAY, an error is
     signalled.

   symbol-bound?

 -- Scheme Procedure: symbol-bound? o s
     Return `#t' if OBARRAY contains a symbol with name STRING bound to
     a defined value.  This differs from SYMBOL-INTERNED? in that the
     mere mention of a symbol usually causes it to be interned;
     `symbol-bound?' determines whether a symbol has been given any
     meaningful value.

   symbol-set!

 -- Scheme Procedure: symbol-set! o s v
     Find the symbol in OBARRAY whose name is STRING, and rebind it to
     VALUE.  An error is signalled if STRING is not present in OBARRAY.

   gentemp

 -- Scheme Procedure: gentemp [prefix [obarray]]
     Create a new symbol with a name unique in an obarray.  The name is
     constructed from an optional string PREFIX and a counter value.
     The default prefix is `t'.  The OBARRAY is specified as a second
     optional argument.  Default is the system obarray where all normal
     symbols are interned.  The counter is increased by 1 at each call.
     There is no provision for resetting the counter.

   guardian-destroyed?

 -- Scheme Procedure: guardian-destroyed? guardian
     Return `#t' if GUARDIAN has been destroyed, otherwise `#f'.

   guardian-greedy?

 -- Scheme Procedure: guardian-greedy? guardian
     Return `#t' if GUARDIAN is a greedy guardian, otherwise `#f'.

   destroy-guardian!

 -- Scheme Procedure: destroy-guardian! guardian
     Destroys GUARDIAN, by making it impossible to put any more objects
     in it or get any objects from it.  It also unguards any objects
     guarded by GUARDIAN.

   make-keyword-from-dash-symbol

 -- Scheme Procedure: make-keyword-from-dash-symbol symbol
     Make a keyword object from a SYMBOL that starts with a dash.

   keyword-dash-symbol

 -- Scheme Procedure: keyword-dash-symbol keyword
     Return the dash symbol for KEYWORD.  This is the inverse of
     `make-keyword-from-dash-symbol'.

   dynamic-link

 -- Scheme Procedure: dynamic-link filename
     Find the shared object (shared library) denoted by FILENAME and
     link it into the running Guile application.  The returned scheme
     object is a "handle" for the library which can be passed to
     `dynamic-func', `dynamic-call' etc.

     Searching for object files is system dependent.  Normally, if
     FILENAME does have an explicit directory it will be searched for
     in locations such as `/usr/lib' and `/usr/local/lib'.

   dynamic-object?

 -- Scheme Procedure: dynamic-object? obj
     Return `#t' if OBJ is a dynamic object handle, or `#f' otherwise.

   dynamic-unlink

 -- Scheme Procedure: dynamic-unlink dobj
     Unlink a dynamic object from the application, if possible.  The
     object must have been linked by `dynamic-link', with DOBJ the
     corresponding handle.  After this procedure is called, the handle
     can no longer be used to access the object.

   dynamic-func

 -- Scheme Procedure: dynamic-func name dobj
     Return a "handle" for the function NAME in the shared object
     referred to by DOBJ.  The handle can be passed to `dynamic-call'
     to actually call the function.

     Regardless whether your C compiler prepends an underscore `_' to
     the global names in a program, you should *not* include this
     underscore in NAME since it will be added automatically when
     necessary.

   dynamic-call

 -- Scheme Procedure: dynamic-call func dobj
     Call a C function in a dynamic object.  Two styles of invocation
     are supported:

        * FUNC can be a function handle returned by `dynamic-func'.  In
          this case DOBJ is ignored

        * FUNC can be a string with the name of the function to call,
          with DOBJ the handle of the dynamic object in which to find
          the function.  This is equivalent to

               (dynamic-call (dynamic-func FUNC DOBJ) #f)

     In either case, the function is passed no arguments and its return
     value is ignored.

   dynamic-args-call

 -- Scheme Procedure: dynamic-args-call func dobj args
     Call the C function indicated by FUNC and DOBJ, just like
     `dynamic-call', but pass it some arguments and return its return
     value.  The C function is expected to take two arguments and
     return an `int', just like `main':
          int c_func (int argc, char **argv);

     The parameter ARGS must be a list of strings and is converted into
     an array of `char *'.  The array is passed in ARGV and its size in
     ARGC.  The return value is converted to a Scheme number and
     returned from the call to `dynamic-args-call'.

   dynamic-wind

 -- Scheme Procedure: dynamic-wind in_guard thunk out_guard
     All three arguments must be 0-argument procedures.  IN_GUARD is
     called, then THUNK, then OUT_GUARD.

     If, any time during the execution of THUNK, the continuation of
     the `dynamic_wind' expression is escaped non-locally, OUT_GUARD is
     called.  If the continuation of the dynamic-wind is re-entered,
     IN_GUARD is called.  Thus IN_GUARD and OUT_GUARD may be called any
     number of times.
          (define x 'normal-binding)
          => x
          (define a-cont  (call-with-current-continuation
          		  (lambda (escape)
          		     (let ((old-x x))
          		       (dynamic-wind
          			  ;; in-guard:
          			  ;;
          			  (lambda () (set! x 'special-binding))

          			  ;; thunk
          			  ;;
          		 	  (lambda () (display x) (newline)
          				     (call-with-current-continuation escape)
          				     (display x) (newline)
          				     x)

          			  ;; out-guard:
          			  ;;
          			  (lambda () (set! x old-x)))))))

          ;; Prints:
          special-binding
          ;; Evaluates to:
          => a-cont
          x
          => normal-binding
          (a-cont #f)
          ;; Prints:
          special-binding
          ;; Evaluates to:
          => a-cont  ;; the value of the (define a-cont...)
          x
          => normal-binding
          a-cont
          => special-binding

   environment?

 -- Scheme Procedure: environment? obj
     Return `#t' if OBJ is an environment, or `#f' otherwise.

   environment-bound?

 -- Scheme Procedure: environment-bound? env sym
     Return `#t' if SYM is bound in ENV, or `#f' otherwise.

   environment-ref

 -- Scheme Procedure: environment-ref env sym
     Return the value of the location bound to SYM in ENV. If SYM is
     unbound in ENV, signal an `environment:unbound' error.

   environment-fold

 -- Scheme Procedure: environment-fold env proc init
     Iterate over all the bindings in ENV, accumulating some value.
     For each binding in ENV, apply PROC to the symbol bound, its
     value, and the result from the previous application of PROC.  Use
     INIT as PROC's third argument the first time PROC is applied.  If
     ENV contains no bindings, this function simply returns INIT.  If
     ENV binds the symbol sym1 to the value val1, sym2 to val2, and so
     on, then this procedure computes:
            (proc sym1 val1
                  (proc sym2 val2
                        ...
                        (proc symn valn
                              init)))
     Each binding in ENV will be processed exactly once.
     `environment-fold' makes no guarantees about the order in which
     the bindings are processed.  Here is a function which, given an
     environment, constructs an association list representing that
     environment's bindings, using environment-fold:
            (define (environment->alist env)
              (environment-fold env
                                (lambda (sym val tail)
                                  (cons (cons sym val) tail))
                                '()))

   environment-define

 -- Scheme Procedure: environment-define env sym val
     Bind SYM to a new location containing VAL in ENV. If SYM is
     already bound to another location in ENV and the binding is
     mutable, that binding is replaced.  The new binding and location
     are both mutable. The return value is unspecified.  If SYM is
     already bound in ENV, and the binding is immutable, signal an
     `environment:immutable-binding' error.

   environment-undefine

 -- Scheme Procedure: environment-undefine env sym
     Remove any binding for SYM from ENV. If SYM is unbound in ENV, do
     nothing.  The return value is unspecified.  If SYM is already
     bound in ENV, and the binding is immutable, signal an
     `environment:immutable-binding' error.

   environment-set!

 -- Scheme Procedure: environment-set! env sym val
     If ENV binds SYM to some location, change that location's value to
     VAL.  The return value is unspecified.  If SYM is not bound in
     ENV, signal an `environment:unbound' error.  If ENV binds SYM to
     an immutable location, signal an `environment:immutable-location'
     error.

   environment-cell

 -- Scheme Procedure: environment-cell env sym for_write
     Return the value cell which ENV binds to SYM, or `#f' if the
     binding does not live in a value cell.  The argument FOR-WRITE
     indicates whether the caller intends to modify the variable's
     value by mutating the value cell.  If the variable is immutable,
     then `environment-cell' signals an
     `environment:immutable-location' error.  If SYM is unbound in ENV,
     signal an `environment:unbound' error.  If you use this function,
     you should consider using `environment-observe', to be notified
     when SYM gets re-bound to a new value cell, or becomes undefined.

   environment-observe

 -- Scheme Procedure: environment-observe env proc
     Whenever ENV's bindings change, apply PROC to ENV.  This function
     returns an object, token, which you can pass to
     `environment-unobserve' to remove PROC from the set of procedures
     observing ENV.  The type and value of token is unspecified.

   environment-observe-weak

 -- Scheme Procedure: environment-observe-weak env proc
     This function is the same as environment-observe, except that the
     reference ENV retains to PROC is a weak reference. This means
     that, if there are no other live, non-weak references to PROC, it
     will be garbage-collected, and dropped from ENV's list of
     observing procedures.

   environment-unobserve

 -- Scheme Procedure: environment-unobserve token
     Cancel the observation request which returned the value TOKEN.
     The return value is unspecified.  If a call `(environment-observe
     env proc)' returns TOKEN, then the call `(environment-unobserve
     token)' will cause PROC to no longer be called when ENV's bindings
     change.

   make-leaf-environment

 -- Scheme Procedure: make-leaf-environment
     Create a new leaf environment, containing no bindings.  All
     bindings and locations created in the new environment will be
     mutable.

   leaf-environment?

 -- Scheme Procedure: leaf-environment? object
     Return `#t' if object is a leaf environment, or `#f' otherwise.

   make-eval-environment

 -- Scheme Procedure: make-eval-environment local imported
     Return a new environment object eval whose bindings are the union
     of the bindings in the environments LOCAL and IMPORTED, with
     bindings from LOCAL taking precedence. Definitions made in eval
     are placed in LOCAL.  Applying `environment-define' or
     `environment-undefine' to eval has the same effect as applying the
     procedure to LOCAL.  Note that eval incorporates LOCAL and
     IMPORTED by reference: If, after creating eval, the program
     changes the bindings of LOCAL or IMPORTED, those changes will be
     visible in eval.  Since most Scheme evaluation takes place in eval
     environments, they transparently cache the bindings received from
     LOCAL and IMPORTED. Thus, the first time the program looks up a
     symbol in eval, eval may make calls to LOCAL or IMPORTED to find
     their bindings, but subsequent references to that symbol will be
     as fast as references to bindings in finite environments.  In
     typical use, LOCAL will be a finite environment, and IMPORTED will
     be an import environment

   eval-environment?

 -- Scheme Procedure: eval-environment? object
     Return `#t' if object is an eval environment, or `#f' otherwise.

   eval-environment-local

 -- Scheme Procedure: eval-environment-local env
     Return the local environment of eval environment ENV.

   eval-environment-set-local!

 -- Scheme Procedure: eval-environment-set-local! env local
     Change ENV's local environment to LOCAL.

   eval-environment-imported

 -- Scheme Procedure: eval-environment-imported env
     Return the imported environment of eval environment ENV.

   eval-environment-set-imported!

 -- Scheme Procedure: eval-environment-set-imported! env imported
     Change ENV's imported environment to IMPORTED.

   make-import-environment

 -- Scheme Procedure: make-import-environment imports conflict_proc
     Return a new environment IMP whose bindings are the union of the
     bindings from the environments in IMPORTS; IMPORTS must be a list
     of environments. That is, IMP binds a symbol to a location when
     some element of IMPORTS does.  If two different elements of
     IMPORTS have a binding for the same symbol, the CONFLICT-PROC is
     called with the following parameters:  the import environment, the
     symbol and the list of the imported environments that bind the
     symbol.  If the CONFLICT-PROC returns an environment ENV, the
     conflict is considered as resolved and the binding from ENV is
     used.  If the CONFLICT-PROC returns some non-environment object,
     the conflict is considered unresolved and the symbol is treated as
     unspecified in the import environment.  The checking for conflicts
     may be performed lazily, i. e. at the moment when a value or
     binding for a certain symbol is requested instead of the moment
     when the environment is created or the bindings of the imports
     change.  All bindings in IMP are immutable. If you apply
     `environment-define' or `environment-undefine' to IMP, Guile will
     signal an  `environment:immutable-binding' error. However, notice
     that the set of bindings in IMP may still change, if one of its
     imported environments changes.

   import-environment?

 -- Scheme Procedure: import-environment? object
     Return `#t' if object is an import environment, or `#f' otherwise.

   import-environment-imports

 -- Scheme Procedure: import-environment-imports env
     Return the list of environments imported by the import environment
     ENV.

   import-environment-set-imports!

 -- Scheme Procedure: import-environment-set-imports! env imports
     Change ENV's list of imported environments to IMPORTS, and check
     for conflicts.

   make-export-environment

 -- Scheme Procedure: make-export-environment private signature
     Return a new environment EXP containing only those bindings in
     private whose symbols are present in SIGNATURE. The PRIVATE
     argument must be an environment.

     The environment EXP binds symbol to location when ENV does, and
     symbol is exported by SIGNATURE.

     SIGNATURE is a list specifying which of the bindings in PRIVATE
     should be visible in EXP. Each element of SIGNATURE should be a
     list of the form:   (symbol attribute ...)  where each attribute
     is one of the following:
    the symbol `mutable-location'
          EXP should treat the   location bound to symbol as mutable.
          That is, EXP   will pass calls to `environment-set!' or
          `environment-cell' directly through to private.

    the symbol `immutable-location'
          EXP should treat   the location bound to symbol as immutable.
          If the program   applies `environment-set!' to EXP and
          symbol, or   calls `environment-cell' to obtain a writable
          value   cell, `environment-set!' will signal an
          `environment:immutable-location' error. Note that, even   if
          an export environment treats a location as immutable, the
          underlying environment may treat it as mutable, so its
          value may change.
     It is an error for an element of signature to specify both
     `mutable-location' and `immutable-location'. If neither is
     specified, `immutable-location' is assumed.

     As a special case, if an element of signature is a lone symbol
     SYM, it is equivalent to an element of the form `(sym)'.

     All bindings in EXP are immutable. If you apply
     `environment-define' or `environment-undefine' to EXP, Guile will
     signal an `environment:immutable-binding' error. However, notice
     that the set of bindings in EXP may still change, if the bindings
     in private change.

   export-environment?

 -- Scheme Procedure: export-environment? object
     Return `#t' if object is an export environment, or `#f' otherwise.

   export-environment-private

 -- Scheme Procedure: export-environment-private env
     Return the private environment of export environment ENV.

   export-environment-set-private!

 -- Scheme Procedure: export-environment-set-private! env private
     Change the private environment of export environment ENV.

   export-environment-signature

 -- Scheme Procedure: export-environment-signature env
     Return the signature of export environment ENV.

   export-environment-set-signature!

 -- Scheme Procedure: export-environment-set-signature! env signature
     Change the signature of export environment ENV.

   eq?

 -- Scheme Procedure: eq? x y
     Return `#t' if X and Y are the same object, except for numbers and
     characters.  For example,

          (define x (vector 1 2 3))
          (define y (vector 1 2 3))

          (eq? x x)  => #t
          (eq? x y)  => #f

     Numbers and characters are not equal to any other object, but the
     problem is they're not necessarily `eq?' to themselves either.
     This is even so when the number comes directly from a variable,

          (let ((n (+ 2 3)))
            (eq? n n))       => *unspecified*

     Generally `eqv?' should be used when comparing numbers or
     characters.  `=' or `char=?' can be used too.

     It's worth noting that end-of-list `()', `#t', `#f', a symbol of a
     given name, and a keyword of a given name, are unique objects.
     There's just one of each, so for instance no matter how `()'
     arises in a program, it's the same object and can be compared with
     `eq?',

          (define x (cdr '(123)))
          (define y (cdr '(456)))
          (eq? x y) => #t

          (define x (string->symbol "foo"))
          (eq? x 'foo) => #t

   eqv?

 -- Scheme Procedure: eqv? x y
     Return `#t' if X and Y are the same object, or for characters and
     numbers the same value.

     On objects except characters and numbers, `eqv?' is the same as
     `eq?', it's true if X and Y are the same object.

     If X and Y are numbers or characters, `eqv?' compares their type
     and value.  An exact number is not `eqv?' to an inexact number
     (even if their value is the same).

          (eqv? 3 (+ 1 2)) => #t
          (eqv? 1 1.0)     => #f

   equal?

 -- Scheme Procedure: equal? x y
     Return `#t' if X and Y are the same type, and their contents or
     value are equal.

     For a pair, string, vector or array, `equal?' compares the
     contents, and does so using using the same `equal?' recursively,
     so a deep structure can be traversed.

          (equal? (list 1 2 3) (list 1 2 3))   => #t
          (equal? (list 1 2 3) (vector 1 2 3)) => #f

     For other objects, `equal?' compares as per `eqv?', which means
     characters and numbers are compared by type and value (and like
     `eqv?', exact and inexact numbers are not `equal?', even if their
     value is the same).

          (equal? 3 (+ 1 2)) => #t
          (equal? 1 1.0)     => #f

     Hash tables are currently only compared as per `eq?', so two
     different tables are not `equal?', even if their contents are the
     same.

     `equal?' does not support circular data structures, it may go into
     an infinite loop if asked to compare two circular lists or similar.

     New application-defined object types (Smobs) have an `equalp'
     handler which is called by `equal?'.  This lets an application
     traverse the contents or control what is considered `equal?' for
     two such objects.  If there's no handler, the default is to just
     compare as per `eq?'.

   scm-error

 -- Scheme Procedure: scm-error key subr message args data
     Raise an error with key KEY.  SUBR can be a string naming the
     procedure associated with the error, or `#f'.  MESSAGE is the
     error message string, possibly containing `~S' and `~A' escapes.
     When an error is reported, these are replaced by formatting the
     corresponding members of ARGS: `~A' (was `%s' in older versions of
     Guile) formats using `display' and `~S' (was `%S') formats using
     `write'.  DATA is a list or `#f' depending on KEY: if KEY is
     `system-error' then it should be a list containing the Unix
     `errno' value; If KEY is `signal' then it should be a list
     containing the Unix signal number; If KEY is `out-of-range' or
     `wrong-type-arg', it is a list containing the bad value; otherwise
     it will usually be `#f'.

   strerror

 -- Scheme Procedure: strerror err
     Return the Unix error message corresponding to ERR, which must be
     an integer value.

   apply:nconc2last

 -- Scheme Procedure: apply:nconc2last lst
     Given a list (ARG1 ... ARGS), this function conses the ARG1 ...
     arguments onto the front of ARGS, and returns the resulting list.
     Note that ARGS is a list; thus, the argument to this function is a
     list whose last element is a list.  Note: Rather than do new
     consing, `apply:nconc2last' destroys its argument, so use with
     care.

   force

 -- Scheme Procedure: force promise
     If the promise X has not been computed yet, compute and return X,
     otherwise just return the previously computed value.

   promise?

 -- Scheme Procedure: promise? obj
     Return true if OBJ is a promise, i.e. a delayed computation (*note
     Delayed evaluation: (r5rs.info)Delayed evaluation.).

   cons-source

 -- Scheme Procedure: cons-source xorig x y
     Create and return a new pair whose car and cdr are X and Y.  Any
     source properties associated with XORIG are also associated with
     the new pair.

   copy-tree

 -- Scheme Procedure: copy-tree obj
     Recursively copy the data tree that is bound to OBJ, and return a
     the new data structure.  `copy-tree' recurses down the contents of
     both pairs and vectors (since both cons cells and vector cells may
     point to arbitrary objects), and stops recursing when it hits any
     other object.

   primitive-eval

 -- Scheme Procedure: primitive-eval exp
     Evaluate EXP in the top-level environment specified by the current
     module.

   eval

 -- Scheme Procedure: eval exp module_or_state
     Evaluate EXP, a list representing a Scheme expression, in the
     top-level environment specified by MODULE_OR_STATE.  While EXP is
     evaluated (using `primitive-eval'), MODULE_OR_STATE is made the
     current module when it is a module, or the current dynamic state
     when it is a dynamic state.Example: (eval '(+ 1 2)
     (interaction-environment))

   eval-options-interface

 -- Scheme Procedure: eval-options-interface [setting]
     Option interface for the evaluation options. Instead of using this
     procedure directly, use the procedures `eval-enable',
     `eval-disable', `eval-set!' and `eval-options'.

   evaluator-traps-interface

 -- Scheme Procedure: evaluator-traps-interface [setting]
     Option interface for the evaluator trap options.

   defined?

 -- Scheme Procedure: defined? sym [env]
     Return `#t' if SYM is defined in the lexical environment ENV.
     When ENV is not specified, look in the top-level environment as
     defined by the current module.

   map-in-order

 -- Scheme Procedure: map-in-order
     implemented by the C function "scm_map"

   self-evaluating?

 -- Scheme Procedure: self-evaluating? obj
     Return #t for objects which Guile considers self-evaluating

   load-extension

 -- Scheme Procedure: load-extension lib init
     Load and initialize the extension designated by LIB and INIT.
     When there is no pre-registered function for LIB/INIT, this is
     equivalent to

          (dynamic-call INIT (dynamic-link LIB))

     When there is a pre-registered function, that function is called
     instead.

     Normally, there is no pre-registered function.  This option exists
     only for situations where dynamic linking is unavailable or
     unwanted.  In that case, you would statically link your program
     with the desired library, and register its init function right
     after Guile has been initialized.

     LIB should be a string denoting a shared library without any file
     type suffix such as ".so".  The suffix is provided automatically.
     It should also not contain any directory components.  Libraries
     that implement Guile Extensions should be put into the normal
     locations for shared libraries.  We recommend to use the naming
     convention libguile-bla-blum for a extension related to a module
     `(bla blum)'.

     The normal way for a extension to be used is to write a small
     Scheme file that defines a module, and to load the extension into
     this module.  When the module is auto-loaded, the extension is
     loaded as well.  For example,

          (define-module (bla blum))

          (load-extension "libguile-bla-blum" "bla_init_blum")

   program-arguments

 -- Scheme Procedure: program-arguments
 -- Scheme Procedure: command-line
     Return the list of command line arguments passed to Guile, as a
     list of strings.  The list includes the invoked program name,
     which is usually `"guile"', but excludes switches and parameters
     for command line options like `-e' and `-l'.

   set-program-arguments

 -- Scheme Procedure: set-program-arguments lst
     Set the command line arguments to be returned by
     `program-arguments' (and `command-line').  LST should be a list of
     strings, the first of which is the program name (either a script
     name, or just `"guile"').

     Program arguments are held in a fluid and therefore have a
     separate value in each Guile thread.  Neither the list nor the
     strings within it are copied, so should not be modified later.

   make-fluid

 -- Scheme Procedure: make-fluid
     Return a newly created fluid.  Fluids are objects that can hold one
     value per dynamic state.  That is, modifications to this value are
     only visible to code that executes with the same dynamic state as
     the modifying code.  When a new dynamic state is constructed, it
     inherits the values from its parent.  Because each thread normally
     executes with its own dynamic state, you can use fluids for thread
     local storage.

   fluid?

 -- Scheme Procedure: fluid? obj
     Return `#t' iff OBJ is a fluid; otherwise, return `#f'.

   fluid-ref

 -- Scheme Procedure: fluid-ref fluid
     Return the value associated with FLUID in the current dynamic
     root.  If FLUID has not been set, then return `#f'.

   fluid-set!

 -- Scheme Procedure: fluid-set! fluid value
     Set the value associated with FLUID in the current dynamic root.

   with-fluids*

 -- Scheme Procedure: with-fluids* fluids values thunk
     Set FLUIDS to VALUES temporary, and call THUNK.  FLUIDS must be a
     list of fluids and VALUES must be the same number of their values
     to be applied.  Each substitution is done one after another.
     THUNK must be a procedure with no argument.

   with-fluid*

 -- Scheme Procedure: with-fluid* fluid value thunk
     Set FLUID to VALUE temporarily, and call THUNK.  THUNK must be a
     procedure with no argument.

   make-dynamic-state

 -- Scheme Procedure: make-dynamic-state [parent]
     Return a copy of the dynamic state object PARENT or of the current
     dynamic state when PARENT is omitted.

   dynamic-state?

 -- Scheme Procedure: dynamic-state? obj
     Return `#t' if OBJ is a dynamic state object; return `#f' otherwise

   current-dynamic-state

 -- Scheme Procedure: current-dynamic-state
     Return the current dynamic state object.

   set-current-dynamic-state

 -- Scheme Procedure: set-current-dynamic-state state
     Set the current dynamic state object to STATE and return the
     previous current dynamic state object.

   with-dynamic-state

 -- Scheme Procedure: with-dynamic-state state proc
     Call PROC while STATE is the current dynamic state object.

   setvbuf

 -- Scheme Procedure: setvbuf port mode [size]
     Set the buffering mode for PORT.  MODE can be:
    `_IONBF'
          non-buffered

    `_IOLBF'
          line buffered

    `_IOFBF'
          block buffered, using a newly allocated buffer of SIZE bytes.
          If SIZE is omitted, a default size will be used.

   file-port?

 -- Scheme Procedure: file-port? obj
     Determine whether OBJ is a port that is related to a file.

   open-file

 -- Scheme Procedure: open-file filename mode
     Open the file whose name is FILENAME, and return a port
     representing that file.  The attributes of the port are determined
     by the MODE string.  The way in which this is interpreted is
     similar to C stdio.  The first character must be one of the
     following:
    `r'
          Open an existing file for input.

    `w'
          Open a file for output, creating it if it doesn't already
          exist or removing its contents if it does.

    `a'
          Open a file for output, creating it if it doesn't already
          exist.  All writes to the port will go to the end of the file.
          The "append mode" can be turned off while the port is in use
          *note fcntl: Ports and File Descriptors.
     The following additional characters can be appended:
    `b'
          Open the underlying file in binary mode, if supported by the
          operating system.

    `+'
          Open the port for both input and output.  E.g., `r+': open an
          existing file for both input and output.

    `0'
          Create an "unbuffered" port.  In this case input and output
          operations are passed directly to the underlying port
          implementation without additional buffering.  This is likely
          to slow down I/O operations.  The buffering mode can be
          changed while a port is in use *note setvbuf: Ports and File
          Descriptors.

    `l'
          Add line-buffering to the port.  The port output buffer will
          be automatically flushed whenever a newline character is
          written.
     In theory we could create read/write ports which were buffered in
     one direction only.  However this isn't included in the current
     interfaces.  If a file cannot be opened with the access requested,
     `open-file' throws an exception.

   gc-live-object-stats

 -- Scheme Procedure: gc-live-object-stats
     Return an alist of statistics of the current live objects.

   gc-stats

 -- Scheme Procedure: gc-stats
     Return an association list of statistics about Guile's current use
     of storage.


   object-address

 -- Scheme Procedure: object-address obj
     Return an integer that for the lifetime of OBJ is uniquely
     returned by this function for OBJ

   gc

 -- Scheme Procedure: gc
     Scans all of SCM objects and reclaims for further use those that
     are no longer accessible.

   class-of

 -- Scheme Procedure: class-of x
     Return the class of X.

   %compute-slots

 -- Scheme Procedure: %compute-slots class
     Return a list consisting of the names of all slots belonging to
     class CLASS, i. e. the slots of CLASS and of all of its
     superclasses.

   get-keyword

 -- Scheme Procedure: get-keyword key l default_value
     Determine an associated value for the keyword KEY from the list L.
     The list L has to consist of an even number of elements, where,
     starting with the first, every second element is a keyword,
     followed by its associated value.  If L does not hold a value for
     KEY, the value DEFAULT_VALUE is returned.

   %initialize-object

 -- Scheme Procedure: %initialize-object obj initargs
     Initialize the object OBJ with the given arguments INITARGS.

   %prep-layout!

 -- Scheme Procedure: %prep-layout! class

   %inherit-magic!

 -- Scheme Procedure: %inherit-magic! class dsupers

   instance?

 -- Scheme Procedure: instance? obj
     Return `#t' if OBJ is an instance.

   class-name

 -- Scheme Procedure: class-name obj
     Return the class name of OBJ.

   class-direct-supers

 -- Scheme Procedure: class-direct-supers obj
     Return the direct superclasses of the class OBJ.

   class-direct-slots

 -- Scheme Procedure: class-direct-slots obj
     Return the direct slots of the class OBJ.

   class-direct-subclasses

 -- Scheme Procedure: class-direct-subclasses obj
     Return the direct subclasses of the class OBJ.

   class-direct-methods

 -- Scheme Procedure: class-direct-methods obj
     Return the direct methods of the class OBJ

   class-precedence-list

 -- Scheme Procedure: class-precedence-list obj
     Return the class precedence list of the class OBJ.

   class-slots

 -- Scheme Procedure: class-slots obj
     Return the slot list of the class OBJ.

   class-environment

 -- Scheme Procedure: class-environment obj
     Return the environment of the class OBJ.

   generic-function-name

 -- Scheme Procedure: generic-function-name obj
     Return the name of the generic function OBJ.

   generic-function-methods

 -- Scheme Procedure: generic-function-methods obj
     Return the methods of the generic function OBJ.

   method-generic-function

 -- Scheme Procedure: method-generic-function obj
     Return the generic function for the method OBJ.

   method-specializers

 -- Scheme Procedure: method-specializers obj
     Return specializers of the method OBJ.

   method-procedure

 -- Scheme Procedure: method-procedure obj
     Return the procedure of the method OBJ.

   accessor-method-slot-definition

 -- Scheme Procedure: accessor-method-slot-definition obj
     Return the slot definition of the accessor OBJ.

   %tag-body

 -- Scheme Procedure: %tag-body body
     Internal GOOPS magic--don't use this function!

   make-unbound

 -- Scheme Procedure: make-unbound
     Return the unbound value.

   unbound?

 -- Scheme Procedure: unbound? obj
     Return `#t' if OBJ is unbound.

   assert-bound

 -- Scheme Procedure: assert-bound value obj
     Return VALUE if it is bound, and invoke the SLOT-UNBOUND method of
     OBJ if it is not.

   @assert-bound-ref

 -- Scheme Procedure: @assert-bound-ref obj index
     Like `assert-bound', but use INDEX for accessing the value from
     OBJ.

   %fast-slot-ref

 -- Scheme Procedure: %fast-slot-ref obj index
     Return the slot value with index INDEX from OBJ.

   %fast-slot-set!

 -- Scheme Procedure: %fast-slot-set! obj index value
     Set the slot with index INDEX in OBJ to VALUE.

   slot-ref-using-class

 -- Scheme Procedure: slot-ref-using-class class obj slot_name

   slot-set-using-class!

 -- Scheme Procedure: slot-set-using-class! class obj slot_name value

   slot-bound-using-class?

 -- Scheme Procedure: slot-bound-using-class? class obj slot_name

   slot-exists-using-class?

 -- Scheme Procedure: slot-exists-using-class? class obj slot_name

   slot-ref

 -- Scheme Procedure: slot-ref obj slot_name
     Return the value from OBJ's slot with the name SLOT_NAME.

   slot-set!

 -- Scheme Procedure: slot-set! obj slot_name value
     Set the slot named SLOT_NAME of OBJ to VALUE.

   slot-bound?

 -- Scheme Procedure: slot-bound? obj slot_name
     Return `#t' if the slot named SLOT_NAME of OBJ is bound.

   slot-exists?

 -- Scheme Procedure: slot-exists? obj slot_name
     Return `#t' if OBJ has a slot named SLOT_NAME.

   %allocate-instance

 -- Scheme Procedure: %allocate-instance class initargs
     Create a new instance of class CLASS and initialize it from the
     arguments INITARGS.

   %set-object-setter!

 -- Scheme Procedure: %set-object-setter! obj setter

   %modify-instance

 -- Scheme Procedure: %modify-instance old new

   %modify-class

 -- Scheme Procedure: %modify-class old new

   %invalidate-class

 -- Scheme Procedure: %invalidate-class class

   %invalidate-method-cache!

 -- Scheme Procedure: %invalidate-method-cache! gf

   generic-capability?

 -- Scheme Procedure: generic-capability? proc

   enable-primitive-generic!

 -- Scheme Procedure: enable-primitive-generic! . subrs

   primitive-generic-generic

 -- Scheme Procedure: primitive-generic-generic subr

   make

 -- Scheme Procedure: make . args
     Make a new object.  ARGS must contain the class and all necessary
     initialization information.

   find-method

 -- Scheme Procedure: find-method . l

   %method-more-specific?

 -- Scheme Procedure: %method-more-specific? m1 m2 targs
     Return true if method M1 is more specific than M2 given the
     argument types (classes) listed in TARGS.

   %goops-loaded

 -- Scheme Procedure: %goops-loaded
     Announce that GOOPS is loaded and perform initialization on the C
     level which depends on the loaded GOOPS modules.

   make-guardian

 -- Scheme Procedure: make-guardian
     Create a new guardian.  A guardian protects a set of objects from
     garbage collection, allowing a program to apply cleanup or other
     actions.

     `make-guardian' returns a procedure representing the guardian.
     Calling the guardian procedure with an argument adds the argument
     to the guardian's set of protected objects.  Calling the guardian
     procedure without an argument returns one of the protected objects
     which are ready for garbage collection, or `#f' if no such object
     is available.  Objects which are returned in this way are removed
     from the guardian.

     You can put a single object into a guardian more than once and you
     can put a single object into more than one guardian.  The object
     will then be returned multiple times by the guardian procedures.

     An object is eligible to be returned from a guardian when it is no
     longer referenced from outside any guardian.

     There is no guarantee about the order in which objects are returned
     from a guardian.  If you want to impose an order on finalization
     actions, for example, you can do that by keeping objects alive in
     some global data structure until they are no longer needed for
     finalizing other objects.

     Being an element in a weak vector, a key in a hash table with weak
     keys, or a value in a hash table with weak value does not prevent
     an object from being returned by a guardian.  But as long as an
     object can be returned from a guardian it will not be removed from
     such a weak vector or hash table.  In other words, a weak link
     does not prevent an object from being considered collectable, but
     being inside a guardian prevents a weak link from being broken.

     A key in a weak key hash table can be though of as having a strong
     reference to its associated value as long as the key is accessible.
     Consequently, when the key only accessible from within a guardian,
     the reference from the key to the value is also considered to be
     coming from within a guardian.  Thus, if there is no other
     reference to the value, it is eligible to be returned from a
     guardian.


   hashq

 -- Scheme Procedure: hashq key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `eq?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.  Note that `hashq' may use internal addresses.  Thus two
     calls to hashq where the keys are `eq?' are not guaranteed to
     deliver the same value if the key object gets garbage collected in
     between.  This can happen, for example with symbols: `(hashq 'foo
     n) (gc) (hashq 'foo n)' may produce two different values, since
     `foo' will be garbage collected.

   hashv

 -- Scheme Procedure: hashv key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `eqv?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.  Note that `(hashv key)' may use internal addresses.  Thus
     two calls to hashv where the keys are `eqv?' are not guaranteed to
     deliver the same value if the key object gets garbage collected in
     between.  This can happen, for example with symbols: `(hashv 'foo
     n) (gc) (hashv 'foo n)' may produce two different values, since
     `foo' will be garbage collected.

   hash

 -- Scheme Procedure: hash key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `equal?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.

   make-hash-table

 -- Scheme Procedure: make-hash-table [n]
     Make a new abstract hash table object with minimum number of
     buckets N


   make-weak-key-hash-table

 -- Scheme Procedure: make-weak-key-hash-table [n]
 -- Scheme Procedure: make-weak-value-hash-table size
 -- Scheme Procedure: make-doubly-weak-hash-table size
     Return a weak hash table with SIZE buckets.

     You can modify weak hash tables in exactly the same way you would
     modify regular hash tables. (*note Hash Tables::)

   make-weak-value-hash-table

 -- Scheme Procedure: make-weak-value-hash-table [n]
     Return a hash table with weak values with SIZE buckets.  (*note
     Hash Tables::)

   make-doubly-weak-hash-table

 -- Scheme Procedure: make-doubly-weak-hash-table n
     Return a hash table with weak keys and values with SIZE buckets.
     (*note Hash Tables::)

   hash-table?

 -- Scheme Procedure: hash-table? obj
     Return `#t' if OBJ is an abstract hash table object.

   weak-key-hash-table?

 -- Scheme Procedure: weak-key-hash-table? obj
 -- Scheme Procedure: weak-value-hash-table? obj
 -- Scheme Procedure: doubly-weak-hash-table? obj
     Return `#t' if OBJ is the specified weak hash table. Note that a
     doubly weak hash table is neither a weak key nor a weak value hash
     table.

   weak-value-hash-table?

 -- Scheme Procedure: weak-value-hash-table? obj
     Return `#t' if OBJ is a weak value hash table.

   doubly-weak-hash-table?

 -- Scheme Procedure: doubly-weak-hash-table? obj
     Return `#t' if OBJ is a doubly weak hash table.

   hash-clear!

 -- Scheme Procedure: hash-clear! table
     Remove all items from TABLE (without triggering a resize).

   hashq-get-handle

 -- Scheme Procedure: hashq-get-handle table key
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `eq?' for equality testing.

   hashq-create-handle!

 -- Scheme Procedure: hashq-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

   hashq-ref

 -- Scheme Procedure: hashq-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `eq?' for equality
     testing.

   hashq-set!

 -- Scheme Procedure: hashq-set! table key val
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `eq?' for equality testing.

   hashq-remove!

 -- Scheme Procedure: hashq-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `eq?' for equality tests.

   hashv-get-handle

 -- Scheme Procedure: hashv-get-handle table key
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `eqv?' for equality testing.

   hashv-create-handle!

 -- Scheme Procedure: hashv-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

   hashv-ref

 -- Scheme Procedure: hashv-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `eqv?' for equality
     testing.

   hashv-set!

 -- Scheme Procedure: hashv-set! table key val
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `eqv?' for equality testing.

   hashv-remove!

 -- Scheme Procedure: hashv-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `eqv?' for equality tests.

   hash-get-handle

 -- Scheme Procedure: hash-get-handle table key
     This procedure returns the `(key . value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `equal?' for equality testing.

   hash-create-handle!

 -- Scheme Procedure: hash-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If
     KEY is not already present, a new handle is created which
     associates KEY with INIT.

   hash-ref

 -- Scheme Procedure: hash-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DEFAULT (or `#f'
     if no DEFAULT argument is supplied).  Uses `equal?' for equality
     testing.

   hash-set!

 -- Scheme Procedure: hash-set! table key val
     Find the entry in TABLE associated with KEY, and store VALUE
     there. Uses `equal?' for equality testing.

   hash-remove!

 -- Scheme Procedure: hash-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `equal?' for equality tests.

   hashx-get-handle

 -- Scheme Procedure: hashx-get-handle hash assoc table key
     This behaves the same way as the corresponding `-get-handle'
     function, but uses HASH as a hash function and ASSOC to compare
     keys.  `hash' must be a function that takes two arguments, a key
     to be hashed and a table size.  `assoc' must be an associator
     function, like `assoc', `assq' or `assv'.

   hashx-create-handle!

 -- Scheme Procedure: hashx-create-handle! hash assoc table key init
     This behaves the same way as the corresponding `-create-handle'
     function, but uses HASH as a hash function and ASSOC to compare
     keys.  `hash' must be a function that takes two arguments, a key
     to be hashed and a table size.  `assoc' must be an associator
     function, like `assoc', `assq' or `assv'.

   hashx-ref

 -- Scheme Procedure: hashx-ref hash assoc table key [dflt]
     This behaves the same way as the corresponding `ref' function, but
     uses HASH as a hash function and ASSOC to compare keys.  `hash'
     must be a function that takes two arguments, a key to be hashed
     and a table size.  `assoc' must be an associator function, like
     `assoc', `assq' or `assv'.

     By way of illustration, `hashq-ref table key' is equivalent to
     `hashx-ref hashq assq table key'.

   hashx-set!

 -- Scheme Procedure: hashx-set! hash assoc table key val
     This behaves the same way as the corresponding `set!' function,
     but uses HASH as a hash function and ASSOC to compare keys.
     `hash' must be a function that takes two arguments, a key to be
     hashed and a table size.  `assoc' must be an associator function,
     like `assoc', `assq' or `assv'.

     By way of illustration, `hashq-set! table key' is equivalent to
     `hashx-set!  hashq assq table key'.

   hashx-remove!

 -- Scheme Procedure: hashx-remove! hash assoc table obj
     This behaves the same way as the corresponding `remove!' function,
     but uses HASH as a hash function and ASSOC to compare keys.
     `hash' must be a function that takes two arguments, a key to be
     hashed and a table size.  `assoc' must be an associator function,
     like `assoc', `assq' or `assv'.

     By way of illustration, `hashq-remove! table key' is equivalent to
     `hashx-remove!  hashq assq #f table key'.

   hash-fold

 -- Scheme Procedure: hash-fold proc init table
     An iterator over hash-table elements.  Accumulates and returns a
     result by applying PROC successively.  The arguments to PROC are
     "(key value prior-result)" where key and value are successive
     pairs from the hash table TABLE, and prior-result is either INIT
     (for the first application of PROC) or the return value of the
     previous application of PROC.  For example, `(hash-fold acons '()
     tab)' will convert a hash table into an a-list of key-value pairs.

   hash-for-each

 -- Scheme Procedure: hash-for-each proc table
     An iterator over hash-table elements.  Applies PROC successively
     on all hash table items.  The arguments to PROC are "(key value)"
     where key and value are successive pairs from the hash table TABLE.

   hash-for-each-handle

 -- Scheme Procedure: hash-for-each-handle proc table
     An iterator over hash-table elements.  Applies PROC successively
     on all hash table handles.

   hash-map->list

 -- Scheme Procedure: hash-map->list proc table
     An iterator over hash-table elements.  Accumulates and returns as
     a list the results of applying PROC successively.  The arguments
     to PROC are "(key value)" where key and value are successive pairs
     from the hash table TABLE.

   make-hook

 -- Scheme Procedure: make-hook [n_args]
     Create a hook for storing procedure of arity N_ARGS.  N_ARGS
     defaults to zero.  The returned value is a hook object to be used
     with the other hook procedures.

   hook?

 -- Scheme Procedure: hook? x
     Return `#t' if X is a hook, `#f' otherwise.

   hook-empty?

 -- Scheme Procedure: hook-empty? hook
     Return `#t' if HOOK is an empty hook, `#f' otherwise.

   add-hook!

 -- Scheme Procedure: add-hook! hook proc [append_p]
     Add the procedure PROC to the hook HOOK. The procedure is added to
     the end if APPEND_P is true, otherwise it is added to the front.
     The return value of this procedure is not specified.

   remove-hook!

 -- Scheme Procedure: remove-hook! hook proc
     Remove the procedure PROC from the hook HOOK.  The return value of
     this procedure is not specified.

   reset-hook!

 -- Scheme Procedure: reset-hook! hook
     Remove all procedures from the hook HOOK.  The return value of
     this procedure is not specified.

   run-hook

 -- Scheme Procedure: run-hook hook . args
     Apply all procedures from the hook HOOK to the arguments ARGS.
     The order of the procedure application is first to last.  The
     return value of this procedure is not specified.

   hook->list

 -- Scheme Procedure: hook->list hook
     Convert the procedure list of HOOK to a list.

   gettext

 -- Scheme Procedure: gettext msgid [domain [category]]
     Return the translation of MSGID in the message domain DOMAIN.
     DOMAIN is optional and defaults to the domain set through
     (textdomain).  CATEGORY is optional and defaults to LC_MESSAGES.

   ngettext

 -- Scheme Procedure: ngettext msgid msgid_plural n [domain [category]]
     Return the translation of MSGID/MSGID_PLURAL in the message domain
     DOMAIN, with the plural form being chosen appropriately for the
     number N.  DOMAIN is optional and defaults to the domain set
     through (textdomain). CATEGORY is optional and defaults to
     LC_MESSAGES.

   textdomain

 -- Scheme Procedure: textdomain [domainname]
     If optional parameter DOMAINNAME is supplied, set the textdomain.
     Return the textdomain.

   bindtextdomain

 -- Scheme Procedure: bindtextdomain domainname [directory]
     If optional parameter DIRECTORY is supplied, set message catalogs
     to directory DIRECTORY.  Return the directory bound to DOMAINNAME.

   bind-textdomain-codeset

 -- Scheme Procedure: bind-textdomain-codeset domainname [encoding]
     If optional parameter ENCODING is supplied, set encoding for
     message catalogs of DOMAINNAME.  Return the encoding of DOMAINNAME.

   ftell

 -- Scheme Procedure: ftell fd_port
     Return an integer representing the current position of FD/PORT,
     measured from the beginning.  Equivalent to:

          (seek port 0 SEEK_CUR)

   redirect-port

 -- Scheme Procedure: redirect-port old new
     This procedure takes two ports and duplicates the underlying file
     descriptor from OLD-PORT into NEW-PORT.  The current file
     descriptor in NEW-PORT will be closed.  After the redirection the
     two ports will share a file position and file status flags.

     The return value is unspecified.

     Unexpected behaviour can result if both ports are subsequently used
     and the original and/or duplicate ports are buffered.

     This procedure does not have any side effects on other ports or
     revealed counts.

   dup->fdes

 -- Scheme Procedure: dup->fdes fd_or_port [fd]
     Return a new integer file descriptor referring to the open file
     designated by FD_OR_PORT, which must be either an open file port
     or a file descriptor.

   dup2

 -- Scheme Procedure: dup2 oldfd newfd
     A simple wrapper for the `dup2' system call.  Copies the file
     descriptor OLDFD to descriptor number NEWFD, replacing the
     previous meaning of NEWFD.  Both OLDFD and NEWFD must be integers.
     Unlike for dup->fdes or primitive-move->fdes, no attempt is made
     to move away ports which are using NEWFD.  The return value is
     unspecified.

   fileno

 -- Scheme Procedure: fileno port
     Return the integer file descriptor underlying PORT.  Does not
     change its revealed count.

   isatty?

 -- Scheme Procedure: isatty? port
     Return `#t' if PORT is using a serial non-file device, otherwise
     `#f'.

   fdopen

 -- Scheme Procedure: fdopen fdes modes
     Return a new port based on the file descriptor FDES.  Modes are
     given by the string MODES.  The revealed count of the port is
     initialized to zero.  The modes string is the same as that
     accepted by *note open-file: File Ports.

   primitive-move->fdes

 -- Scheme Procedure: primitive-move->fdes port fd
     Moves the underlying file descriptor for PORT to the integer value
     FDES without changing the revealed count of PORT.  Any other ports
     already using this descriptor will be automatically shifted to new
     descriptors and their revealed counts reset to zero.  The return
     value is `#f' if the file descriptor already had the required
     value or `#t' if it was moved.

   fdes->ports

 -- Scheme Procedure: fdes->ports fd
     Return a list of existing ports which have FDES as an underlying
     file descriptor, without changing their revealed counts.

   keyword?

 -- Scheme Procedure: keyword? obj
     Return `#t' if the argument OBJ is a keyword, else `#f'.

   symbol->keyword

 -- Scheme Procedure: symbol->keyword symbol
     Return the keyword with the same name as SYMBOL.

   keyword->symbol

 -- Scheme Procedure: keyword->symbol keyword
     Return the symbol with the same name as KEYWORD.

   make-list

 -- Scheme Procedure: make-list n [init]
     Create a list containing of N elements, where each element is
     initialized to INIT.  INIT defaults to the empty list `()' if not
     given.

   cons*

 -- Scheme Procedure: cons* arg . rest
     Like `list', but the last arg provides the tail of the constructed
     list, returning `(cons ARG1 (cons ARG2 (cons ... ARGN)))'.
     Requires at least one argument.  If given one argument, that
     argument is returned as result.  This function is called `list*'
     in some other Schemes and in Common LISP.

   null?

 -- Scheme Procedure: null? x
     Return `#t' iff X is the empty list, else `#f'.

   list?

 -- Scheme Procedure: list? x
     Return `#t' iff X is a proper list, else `#f'.

   length

 -- Scheme Procedure: length lst
     Return the number of elements in list LST.

   append

 -- Scheme Procedure: append . args
     Return a list consisting of the elements the lists passed as
     arguments.
          (append '(x) '(y))          =>  (x y)
          (append '(a) '(b c d))      =>  (a b c d)
          (append '(a (b)) '((c)))    =>  (a (b) (c))
     The resulting list is always newly allocated, except that it
     shares structure with the last list argument.  The last argument
     may actually be any object; an improper list results if the last
     argument is not a proper list.
          (append '(a b) '(c . d))    =>  (a b c . d)
          (append '() 'a)             =>  a

   append!

 -- Scheme Procedure: append! . lists
     A destructive version of `append' (*note Pairs and Lists:
     (r5rs)Pairs and Lists.).  The cdr field of each list's final pair
     is changed to point to the head of the next list, so no consing is
     performed.  Return the mutated list.

   last-pair

 -- Scheme Procedure: last-pair lst
     Return the last pair in LST, signalling an error if LST is
     circular.

   reverse

 -- Scheme Procedure: reverse lst
     Return a new list that contains the elements of LST but in reverse
     order.

   reverse!

 -- Scheme Procedure: reverse! lst [new_tail]
     A destructive version of `reverse' (*note Pairs and Lists:
     (r5rs)Pairs and Lists.).  The cdr of each cell in LST is modified
     to point to the previous list element.  Return the reversed list.

     Caveat: because the list is modified in place, the tail of the
     original list now becomes its head, and the head of the original
     list now becomes the tail.  Therefore, the LST symbol to which the
     head of the original list was bound now points to the tail.  To
     ensure that the head of the modified list is not lost, it is wise
     to save the return value of `reverse!'

   list-ref

 -- Scheme Procedure: list-ref list k
     Return the Kth element from LIST.

   list-set!

 -- Scheme Procedure: list-set! list k val
     Set the Kth element of LIST to VAL.

   list-cdr-ref

 -- Scheme Procedure: list-cdr-ref
     implemented by the C function "scm_list_tail"

   list-tail

 -- Scheme Procedure: list-tail lst k
 -- Scheme Procedure: list-cdr-ref lst k
     Return the "tail" of LST beginning with its Kth element.  The
     first element of the list is considered to be element 0.

     `list-tail' and `list-cdr-ref' are identical.  It may help to
     think of `list-cdr-ref' as accessing the Kth cdr of the list, or
     returning the results of cdring K times down LST.

   list-cdr-set!

 -- Scheme Procedure: list-cdr-set! list k val
     Set the Kth cdr of LIST to VAL.

   list-head

 -- Scheme Procedure: list-head lst k
     Copy the first K elements from LST into a new list, and return it.

   list-copy

 -- Scheme Procedure: list-copy lst
     Return a (newly-created) copy of LST.

   list

 -- Scheme Procedure: list . objs
     Return a list containing OBJS, the arguments to `list'.

   memq

 -- Scheme Procedure: memq x lst
     Return the first sublist of LST whose car is `eq?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

   memv

 -- Scheme Procedure: memv x lst
     Return the first sublist of LST whose car is `eqv?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

   member

 -- Scheme Procedure: member x lst
     Return the first sublist of LST whose car is `equal?' to X where
     the sublists of LST are the non-empty lists returned by
     `(list-tail LST K)' for K less than the length of LST.  If X does
     not occur in LST, then `#f' (not the empty list) is returned.

   delq!

 -- Scheme Procedure: delq! item lst
 -- Scheme Procedure: delv! item lst
 -- Scheme Procedure: delete! item lst
     These procedures are destructive versions of `delq', `delv' and
     `delete': they modify the existing LST rather than creating a new
     list.  Caveat evaluator: Like other destructive list functions,
     these functions cannot modify the binding of LST, and so cannot be
     used to delete the first element of LST destructively.

   delv!

 -- Scheme Procedure: delv! item lst
     Destructively remove all elements from LST that are `eqv?' to ITEM.

   delete!

 -- Scheme Procedure: delete! item lst
     Destructively remove all elements from LST that are `equal?' to
     ITEM.

   delq

 -- Scheme Procedure: delq item lst
     Return a newly-created copy of LST with elements `eq?' to ITEM
     removed.  This procedure mirrors `memq': `delq' compares elements
     of LST against ITEM with `eq?'.

   delv

 -- Scheme Procedure: delv item lst
     Return a newly-created copy of LST with elements `eqv?'  to ITEM
     removed.  This procedure mirrors `memv': `delv' compares elements
     of LST against ITEM with `eqv?'.

   delete

 -- Scheme Procedure: delete item lst
     Return a newly-created copy of LST with elements `equal?'  to ITEM
     removed.  This procedure mirrors `member': `delete' compares
     elements of LST against ITEM with `equal?'.

   delq1!

 -- Scheme Procedure: delq1! item lst
     Like `delq!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eq?'.  See also `delv1!' and
     `delete1!'.

   delv1!

 -- Scheme Procedure: delv1! item lst
     Like `delv!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eqv?'.  See also `delq1!' and
     `delete1!'.

   delete1!

 -- Scheme Procedure: delete1! item lst
     Like `delete!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `equal?'.  See also `delq1!' and
     `delv1!'.

   filter

 -- Scheme Procedure: filter pred list
     Return all the elements of 2nd arg LIST that satisfy predicate
     PRED.  The list is not disordered - elements that appear in the
     result list occur in the same order as they occur in the argument
     list. The returned list may share a common tail with the argument
     list. The dynamic order in which the various applications of pred
     are made is not specified.

          (filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)

   filter!

 -- Scheme Procedure: filter! pred list
     Linear-update variant of `filter'.

   primitive-load

 -- Scheme Procedure: primitive-load filename
     Load the file named FILENAME and evaluate its contents in the
     top-level environment. The load paths are not searched; FILENAME
     must either be a full pathname or be a pathname relative to the
     current directory.  If the  variable `%load-hook' is defined, it
     should be bound to a procedure that will be called before any code
     is loaded.  See the documentation for `%load-hook' later in this
     section.

   %package-data-dir

 -- Scheme Procedure: %package-data-dir
     Return the name of the directory where Scheme packages, modules and
     libraries are kept.  On most Unix systems, this will be
     `/usr/local/share/guile'.

   %library-dir

 -- Scheme Procedure: %library-dir
     Return the directory where the Guile Scheme library files are
     installed.  E.g., may return "/usr/share/guile/1.3.5".

   %site-dir

 -- Scheme Procedure: %site-dir
     Return the directory where the Guile site files are installed.
     E.g., may return "/usr/share/guile/site".

   parse-path

 -- Scheme Procedure: parse-path path [tail]
     Parse PATH, which is expected to be a colon-separated string, into
     a list and return the resulting list with TAIL appended. If PATH
     is `#f', TAIL is returned.

   search-path

 -- Scheme Procedure: search-path path filename [extensions]
     Search PATH for a directory containing a file named FILENAME. The
     file must be readable, and not a directory.  If we find one,
     return its full filename; otherwise, return `#f'.  If FILENAME is
     absolute, return it unchanged.  If given, EXTENSIONS is a list of
     strings; for each directory in PATH, we search for FILENAME
     concatenated with each EXTENSION.

   %search-load-path

 -- Scheme Procedure: %search-load-path filename
     Search %LOAD-PATH for the file named FILENAME, which must be
     readable by the current user.  If FILENAME is found in the list of
     paths to search or is an absolute pathname, return its full
     pathname.  Otherwise, return `#f'.  Filenames may have any of the
     optional extensions in the `%load-extensions' list;
     `%search-load-path' will try each extension automatically.

   primitive-load-path

 -- Scheme Procedure: primitive-load-path filename
     Search %LOAD-PATH for the file named FILENAME and load it into the
     top-level environment.  If FILENAME is a relative pathname and is
     not found in the list of search paths, an error is signalled.

   procedure->memoizing-macro

 -- Scheme Procedure: procedure->memoizing-macro code
     Return a "macro" which, when a symbol defined to this value
     appears as the first symbol in an expression, evaluates the result
     of applying CODE to the expression and the environment.

     `procedure->memoizing-macro' is the same as `procedure->macro',
     except that the expression returned by CODE replaces the original
     macro expression in the memoized form of the containing code.

   procedure->syntax

 -- Scheme Procedure: procedure->syntax code
     Return a "macro" which, when a symbol defined to this value
     appears as the first symbol in an expression, returns the result
     of applying CODE to the expression and the environment.

   procedure->macro

 -- Scheme Procedure: procedure->macro code
     Return a "macro" which, when a symbol defined to this value
     appears as the first symbol in an expression, evaluates the result
     of applying CODE to the expression and the environment.  For
     example:

          (define trace
            (procedure->macro
             (lambda (x env) `(set! ,(cadr x) (tracef ,(cadr x) ',(cadr x))))))

          (trace foo) == (set! foo (tracef foo 'foo)).

   macro?

 -- Scheme Procedure: macro? obj
     Return `#t' if OBJ is a regular macro, a memoizing macro or a
     syntax transformer.

   macro-type

 -- Scheme Procedure: macro-type m
     Return one of the symbols `syntax', `macro' or `macro!', depending
     on whether M is a syntax transformer, a regular macro, or a
     memoizing macro, respectively.  If M is not a macro, `#f' is
     returned.

   macro-name

 -- Scheme Procedure: macro-name m
     Return the name of the macro M.

   macro-transformer

 -- Scheme Procedure: macro-transformer m
     Return the transformer of the macro M.

   current-module

 -- Scheme Procedure: current-module
     Return the current module.

   set-current-module

 -- Scheme Procedure: set-current-module module
     Set the current module to MODULE and return the previous current
     module.

   interaction-environment

 -- Scheme Procedure: interaction-environment
     Return a specifier for the environment that contains
     implementation-defined bindings, typically a superset of those
     listed in the report.  The intent is that this procedure will
     return the environment in which the implementation would evaluate
     expressions dynamically typed by the user.

   env-module

 -- Scheme Procedure: env-module env
     Return the module of ENV, a lexical environment.

   standard-eval-closure

 -- Scheme Procedure: standard-eval-closure module
     Return an eval closure for the module MODULE.

   standard-interface-eval-closure

 -- Scheme Procedure: standard-interface-eval-closure module
     Return a interface eval closure for the module MODULE. Such a
     closure does not allow new bindings to be added.

   module-import-interface

 -- Scheme Procedure: module-import-interface module sym

   %get-pre-modules-obarray

 -- Scheme Procedure: %get-pre-modules-obarray
     Return the obarray that is used for all new bindings before the
     module system is booted.  The first call to `set-current-module'
     will boot the module system.

   exact?

 -- Scheme Procedure: exact? x
     Return `#t' if X is an exact number, `#f' otherwise.

   odd?

 -- Scheme Procedure: odd? n
     Return `#t' if N is an odd number, `#f' otherwise.

   even?

 -- Scheme Procedure: even? n
     Return `#t' if N is an even number, `#f' otherwise.

   inf?

 -- Scheme Procedure: inf? x
     Return `#t' if X is either `+inf.0' or `-inf.0', `#f' otherwise.

   nan?

 -- Scheme Procedure: nan? n
     Return `#t' if N is a NaN, `#f' otherwise.

   inf

 -- Scheme Procedure: inf
     Return Inf.

   nan

 -- Scheme Procedure: nan
     Return NaN.

   abs

 -- Scheme Procedure: abs x
     Return the absolute value of X.

   logand

 -- Scheme Procedure: logand n1 n2
     Return the bitwise AND of the integer arguments.

          (logand) => -1
          (logand 7) => 7
          (logand #b111 #b011 #b001) => 1

   logior

 -- Scheme Procedure: logior n1 n2
     Return the bitwise OR of the integer arguments.

          (logior) => 0
          (logior 7) => 7
          (logior #b000 #b001 #b011) => 3

   logxor

 -- Scheme Procedure: logxor n1 n2
     Return the bitwise XOR of the integer arguments.  A bit is set in
     the result if it is set in an odd number of arguments.
          (logxor) => 0
          (logxor 7) => 7
          (logxor #b000 #b001 #b011) => 2
          (logxor #b000 #b001 #b011 #b011) => 1

   logtest

 -- Scheme Procedure: logtest j k
     Test whether J and K have any 1 bits in common.  This is
     equivalent to `(not (zero? (logand j k)))', but without actually
     calculating the `logand', just testing for non-zero.

          (logtest #b0100 #b1011) => #f
          (logtest #b0100 #b0111) => #t

   logbit?

 -- Scheme Procedure: logbit? index j
     Test whether bit number INDEX in J is set.  INDEX starts from 0
     for the least significant bit.

          (logbit? 0 #b1101) => #t
          (logbit? 1 #b1101) => #f
          (logbit? 2 #b1101) => #t
          (logbit? 3 #b1101) => #t
          (logbit? 4 #b1101) => #f

   lognot

 -- Scheme Procedure: lognot n
     Return the integer which is the ones-complement of the integer
     argument.

          (number->string (lognot #b10000000) 2)
             => "-10000001"
          (number->string (lognot #b0) 2)
             => "-1"

   modulo-expt

 -- Scheme Procedure: modulo-expt n k m
     Return N raised to the integer exponent K, modulo M.

          (modulo-expt 2 3 5)
             => 3

   integer-expt

 -- Scheme Procedure: integer-expt n k
     Return N raised to the power K.  K must be an exact integer, N can
     be any number.

     Negative K is supported, and results in 1/n^abs(k) in the usual
     way.  N^0 is 1, as usual, and that includes 0^0 is 1.

          (integer-expt 2 5)   => 32
          (integer-expt -3 3)  => -27
          (integer-expt 5 -3)  => 1/125
          (integer-expt 0 0)   => 1

   ash

 -- Scheme Procedure: ash n cnt
     Return N shifted left by CNT bits, or shifted right if CNT is
     negative.  This is an "arithmetic" shift.

     This is effectively a multiplication by 2^CNT, and when CNT is
     negative it's a division, rounded towards negative infinity.
     (Note that this is not the same rounding as `quotient' does.)

     With N viewed as an infinite precision twos complement, `ash'
     means a left shift introducing zero bits, or a right shift
     dropping bits.

          (number->string (ash #b1 3) 2)     => "1000"
          (number->string (ash #b1010 -1) 2) => "101"

          ;; -23 is bits ...11101001, -6 is bits ...111010
          (ash -23 -2) => -6

   bit-extract

 -- Scheme Procedure: bit-extract n start end
     Return the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in
     the result.

          (number->string (bit-extract #b1101101010 0 4) 2)
             => "1010"
          (number->string (bit-extract #b1101101010 4 9) 2)
             => "10110"

   logcount

 -- Scheme Procedure: logcount n
     Return the number of bits in integer N.  If integer is positive,
     the 1-bits in its binary representation are counted.  If negative,
     the 0-bits in its two's-complement binary representation are
     counted.  If 0, 0 is returned.

          (logcount #b10101010)
             => 4
          (logcount 0)
             => 0
          (logcount -2)
             => 1

   integer-length

 -- Scheme Procedure: integer-length n
     Return the number of bits necessary to represent N.

          (integer-length #b10101010)
             => 8
          (integer-length 0)
             => 0
          (integer-length #b1111)
             => 4

   number->string

 -- Scheme Procedure: number->string n [radix]
     Return a string holding the external representation of the number
     N in the given RADIX.  If N is inexact, a radix of 10 will be used.

   string->number

 -- Scheme Procedure: string->number string [radix]
     Return a number of the maximally precise representation expressed
     by the given STRING. RADIX must be an exact integer, either 2, 8,
     10, or 16. If supplied, RADIX is a default radix that may be
     overridden by an explicit radix prefix in STRING (e.g. "#o177").
     If RADIX is not supplied, then the default radix is 10. If string
     is not a syntactically valid notation for a number, then
     `string->number' returns `#f'.

   number?

 -- Scheme Procedure: number? x
     Return `#t' if X is a number, `#f' otherwise.

   complex?

 -- Scheme Procedure: complex? x
     Return `#t' if X is a complex number, `#f' otherwise.  Note that
     the sets of real, rational and integer values form subsets of the
     set of complex numbers, i. e. the predicate will also be fulfilled
     if X is a real, rational or integer number.

   real?

 -- Scheme Procedure: real? x
     Return `#t' if X is a real number, `#f' otherwise.  Note that the
     set of integer values forms a subset of the set of real numbers,
     i. e. the predicate will also be fulfilled if X is an integer
     number.

   rational?

 -- Scheme Procedure: rational? x
     Return `#t' if X is a rational number, `#f' otherwise.  Note that
     the set of integer values forms a subset of the set of rational
     numbers, i. e. the predicate will also be fulfilled if X is an
     integer number.

   integer?

 -- Scheme Procedure: integer? x
     Return `#t' if X is an integer number, `#f' else.

   inexact?

 -- Scheme Procedure: inexact? x
     Return `#t' if X is an inexact number, `#f' else.

   1+

 -- Scheme Procedure: 1+ x
     Return X+1.

   1-

 -- Scheme Procedure: 1- x
     Return X-1.

   truncate

 -- Scheme Procedure: truncate x
     Round the number X towards zero.

   round

 -- Scheme Procedure: round x
     Round the number X towards the nearest integer. When it is exactly
     halfway between two integers, round towards the even one.

   floor

 -- Scheme Procedure: floor x
     Round the number X towards minus infinity.

   ceiling

 -- Scheme Procedure: ceiling x
     Round the number X towards infinity.

   $expt

 -- Scheme Procedure: $expt x y
     Return X raised to the power of Y. This procedure does not accept
     complex arguments.

   $atan2

 -- Scheme Procedure: $atan2 x y
     Return the arc tangent of the two arguments X and Y. This is
     similar to calculating the arc tangent of X / Y, except that the
     signs of both arguments are used to determine the quadrant of the
     result. This procedure does not accept complex arguments.

   make-rectangular

 -- Scheme Procedure: make-rectangular real_part imaginary_part
     Return a complex number constructed of the given REAL-PART and
     IMAGINARY-PART parts.

   make-polar

 -- Scheme Procedure: make-polar x y
     Return the complex number X * e^(i * Y).

   inexact->exact

 -- Scheme Procedure: inexact->exact z
     Return an exact number that is numerically closest to Z.

   rationalize

 -- Scheme Procedure: rationalize x eps
     Returns the _simplest_ rational number differing from X by no more
     than EPS.

     As required by R5RS, `rationalize' only returns an exact result
     when both its arguments are exact.  Thus, you might need to use
     `inexact->exact' on the arguments.

          (rationalize (inexact->exact 1.2) 1/100)
          => 6/5

   log

 -- Scheme Procedure: log z
     Return the natural logarithm of Z.

   log10

 -- Scheme Procedure: log10 z
     Return the base 10 logarithm of Z.

   exp

 -- Scheme Procedure: exp z
     Return e to the power of Z, where e is the base of natural
     logarithms (2.71828...).

   sqrt

 -- Scheme Procedure: sqrt x
     Return the square root of Z.  Of the two possible roots (positive
     and negative), the one with the a positive real part is returned,
     or if that's zero then a positive imaginary part.  Thus,

          (sqrt 9.0)       => 3.0
          (sqrt -9.0)      => 0.0+3.0i
          (sqrt 1.0+1.0i)  => 1.09868411346781+0.455089860562227i
          (sqrt -1.0-1.0i) => 0.455089860562227-1.09868411346781i

   entity?

 -- Scheme Procedure: entity? obj
     Return `#t' if OBJ is an entity.

   operator?

 -- Scheme Procedure: operator? obj
     Return `#t' if OBJ is an operator.

   valid-object-procedure?

 -- Scheme Procedure: valid-object-procedure? proc
     Return `#t' iff PROC is a procedure that can be used with
     `set-object-procedure'.  It is always valid to use a closure
     constructed by `lambda'.

   set-object-procedure!

 -- Scheme Procedure: set-object-procedure! obj proc
     Set the object procedure of OBJ to PROC.  OBJ must be either an
     entity or an operator.

   make-class-object

 -- Scheme Procedure: make-class-object metaclass layout
     Create a new class object of class METACLASS, with the slot layout
     specified by LAYOUT.

   make-subclass-object

 -- Scheme Procedure: make-subclass-object class layout
     Create a subclass object of CLASS, with the slot layout specified
     by LAYOUT.

   object-properties

 -- Scheme Procedure: object-properties obj
     Return OBJ's property list.

   set-object-properties!

 -- Scheme Procedure: set-object-properties! obj alist
     Set OBJ's property list to ALIST.

   object-property

 -- Scheme Procedure: object-property obj key
     Return the property of OBJ with name KEY.

   set-object-property!

 -- Scheme Procedure: set-object-property! obj key value
     In OBJ's property list, set the property named KEY to VALUE.

   cons

 -- Scheme Procedure: cons x y
     Return a newly allocated pair whose car is X and whose cdr is Y.
     The pair is guaranteed to be different (in the sense of `eq?')
     from every previously existing object.

   pair?

 -- Scheme Procedure: pair? x
     Return `#t' if X is a pair; otherwise return `#f'.

   set-car!

 -- Scheme Procedure: set-car! pair value
     Stores VALUE in the car field of PAIR.  The value returned by
     `set-car!' is unspecified.

   set-cdr!

 -- Scheme Procedure: set-cdr! pair value
     Stores VALUE in the cdr field of PAIR.  The value returned by
     `set-cdr!' is unspecified.

   char-ready?

 -- Scheme Procedure: char-ready? [port]
     Return `#t' if a character is ready on input PORT and return `#f'
     otherwise.  If `char-ready?' returns `#t' then the next
     `read-char' operation on PORT is guaranteed not to hang.  If PORT
     is a file port at end of file then `char-ready?' returns `#t'.

     `char-ready?' exists to make it possible for a program to accept
     characters from interactive ports without getting stuck waiting
     for input.  Any input editors associated with such ports must make
     sure that characters whose existence has been asserted by
     `char-ready?' cannot be rubbed out.  If `char-ready?' were to
     return `#f' at end of file, a port at end of file would be
     indistinguishable from an interactive port that has no ready
     characters.

   drain-input

 -- Scheme Procedure: drain-input port
     This procedure clears a port's input buffers, similar to the way
     that force-output clears the output buffer.  The contents of the
     buffers are returned as a single string, e.g.,

          (define p (open-input-file ...))
          (drain-input p) => empty string, nothing buffered yet.
          (unread-char (read-char p) p)
          (drain-input p) => initial chars from p, up to the buffer size.

     Draining the buffers may be useful for cleanly finishing buffered
     I/O so that the file descriptor can be used directly for further
     input.

   current-input-port

 -- Scheme Procedure: current-input-port
     Return the current input port.  This is the default port used by
     many input procedures.  Initially, `current-input-port' returns
     the "standard input" in Unix and C terminology.

   current-output-port

 -- Scheme Procedure: current-output-port
     Return the current output port.  This is the default port used by
     many output procedures.  Initially, `current-output-port' returns
     the "standard output" in Unix and C terminology.

   current-error-port

 -- Scheme Procedure: current-error-port
     Return the port to which errors and warnings should be sent (the
     "standard error" in Unix and C terminology).

   current-load-port

 -- Scheme Procedure: current-load-port
     Return the current-load-port.  The load port is used internally by
     `primitive-load'.

   set-current-input-port

 -- Scheme Procedure: set-current-input-port port
 -- Scheme Procedure: set-current-output-port port
 -- Scheme Procedure: set-current-error-port port
     Change the ports returned by `current-input-port',
     `current-output-port' and `current-error-port', respectively, so
     that they use the supplied PORT for input or output.

   set-current-output-port

 -- Scheme Procedure: set-current-output-port port
     Set the current default output port to PORT.

   set-current-error-port

 -- Scheme Procedure: set-current-error-port port
     Set the current default error port to PORT.

   port-revealed

 -- Scheme Procedure: port-revealed port
     Return the revealed count for PORT.

   set-port-revealed!

 -- Scheme Procedure: set-port-revealed! port rcount
     Sets the revealed count for a port to a given value.  The return
     value is unspecified.

   port-mode

 -- Scheme Procedure: port-mode port
     Return the port modes associated with the open port PORT.  These
     will not necessarily be identical to the modes used when the port
     was opened, since modes such as "append" which are used only
     during port creation are not retained.

   close-port

 -- Scheme Procedure: close-port port
     Close the specified port object.  Return `#t' if it successfully
     closes a port or `#f' if it was already closed.  An exception may
     be raised if an error occurs, for example when flushing buffered
     output.  See also *note close: Ports and File Descriptors, for a
     procedure which can close file descriptors.

   close-input-port

 -- Scheme Procedure: close-input-port port
     Close the specified input port object.  The routine has no effect
     if the file has already been closed.  An exception may be raised
     if an error occurs.  The value returned is unspecified.

     See also *note close: Ports and File Descriptors, for a procedure
     which can close file descriptors.

   close-output-port

 -- Scheme Procedure: close-output-port port
     Close the specified output port object.  The routine has no effect
     if the file has already been closed.  An exception may be raised
     if an error occurs.  The value returned is unspecified.

     See also *note close: Ports and File Descriptors, for a procedure
     which can close file descriptors.

   port-for-each

 -- Scheme Procedure: port-for-each proc
     Apply PROC to each port in the Guile port table in turn.  The
     return value is unspecified.  More specifically, PROC is applied
     exactly once to every port that exists in the system at the time
     PORT-FOR-EACH is invoked.  Changes to the port table while
     PORT-FOR-EACH is running have no effect as far as PORT-FOR-EACH is
     concerned.

   input-port?

 -- Scheme Procedure: input-port? x
     Return `#t' if X is an input port, otherwise return `#f'.  Any
     object satisfying this predicate also satisfies `port?'.

   output-port?

 -- Scheme Procedure: output-port? x
     Return `#t' if X is an output port, otherwise return `#f'.  Any
     object satisfying this predicate also satisfies `port?'.

   port?

 -- Scheme Procedure: port? x
     Return a boolean indicating whether X is a port.  Equivalent to
     `(or (input-port? X) (output-port?  X))'.

   port-closed?

 -- Scheme Procedure: port-closed? port
     Return `#t' if PORT is closed or `#f' if it is open.

   eof-object?

 -- Scheme Procedure: eof-object? x
     Return `#t' if X is an end-of-file object; otherwise return `#f'.

   force-output

 -- Scheme Procedure: force-output [port]
     Flush the specified output port, or the current output port if PORT
     is omitted.  The current output buffer contents are passed to the
     underlying port implementation (e.g., in the case of fports, the
     data will be written to the file and the output buffer will be
     cleared.)  It has no effect on an unbuffered port.

     The return value is unspecified.

   flush-all-ports

 -- Scheme Procedure: flush-all-ports
     Equivalent to calling `force-output' on all open output ports.
     The return value is unspecified.

   read-char

 -- Scheme Procedure: read-char [port]
     Return the next character available from PORT, updating PORT to
     point to the following character.  If no more characters are
     available, the end-of-file object is returned.

   peek-char

 -- Scheme Procedure: peek-char [port]
     Return the next character available from PORT, _without_ updating
     PORT to point to the following character.  If no more characters
     are available, the end-of-file object is returned.

     The value returned by a call to `peek-char' is the same as the
     value that would have been returned by a call to `read-char' on
     the same port.  The only difference is that the very next call to
     `read-char' or `peek-char' on that PORT will return the value
     returned by the preceding call to `peek-char'.  In particular, a
     call to `peek-char' on an interactive port will hang waiting for
     input whenever a call to `read-char' would have hung.

   unread-char

 -- Scheme Procedure: unread-char cobj [port]
     Place CHAR in PORT so that it will be read by the next read
     operation.  If called multiple times, the unread characters will
     be read again in last-in first-out order.  If PORT is not
     supplied, the current input port is used.

   unread-string

 -- Scheme Procedure: unread-string str port
     Place the string STR in PORT so that its characters will be read
     in subsequent read operations.  If called multiple times, the
     unread characters will be read again in last-in first-out order.
     If PORT is not supplied, the current-input-port is used.

   seek

 -- Scheme Procedure: seek fd_port offset whence
     Sets the current position of FD/PORT to the integer OFFSET, which
     is interpreted according to the value of WHENCE.

     One of the following variables should be supplied for WHENCE:

      -- Variable: SEEK_SET
          Seek from the beginning of the file.

      -- Variable: SEEK_CUR
          Seek from the current position.

      -- Variable: SEEK_END
          Seek from the end of the file.
     If FD/PORT is a file descriptor, the underlying system call is
     `lseek'.  PORT may be a string port.

     The value returned is the new position in the file.  This means
     that the current position of a port can be obtained using:
          (seek port 0 SEEK_CUR)

   truncate-file

 -- Scheme Procedure: truncate-file object [length]
     Truncate FILE to LENGTH bytes.  FILE can be a filename string, a
     port object, or an integer file descriptor.  The return value is
     unspecified.

     For a port or file descriptor LENGTH can be omitted, in which case
     the file is truncated at the current position (per `ftell' above).

     On most systems a file can be extended by giving a length greater
     than the current size, but this is not mandatory in the POSIX
     standard.

   port-line

 -- Scheme Procedure: port-line port
     Return the current line number for PORT.

     The first line of a file is 0.  But you might want to add 1 when
     printing line numbers, since starting from 1 is traditional in
     error messages, and likely to be more natural to non-programmers.

   set-port-line!

 -- Scheme Procedure: set-port-line! port line
     Set the current line number for PORT to LINE.  The first line of a
     file is 0.

   port-column

 -- Scheme Procedure: port-column port
     Return the current column number of PORT.  If the number is
     unknown, the result is #f.  Otherwise, the result is a 0-origin
     integer - i.e. the first character of the first line is line 0,
     column 0.  (However, when you display a file position, for example
     in an error message, we recommend you add 1 to get 1-origin
     integers.  This is because lines and column numbers traditionally
     start with 1, and that is what non-programmers will find most
     natural.)

   set-port-column!

 -- Scheme Procedure: set-port-column! port column
     Set the current column of PORT.  Before reading the first
     character on a line the column should be 0.

   port-filename

 -- Scheme Procedure: port-filename port
     Return the filename associated with PORT.  This function returns
     the strings "standard input", "standard output" and "standard
     error" when called on the current input, output and error ports
     respectively.

   set-port-filename!

 -- Scheme Procedure: set-port-filename! port filename
     Change the filename associated with PORT, using the current input
     port if none is specified.  Note that this does not change the
     port's source of data, but only the value that is returned by
     `port-filename' and reported in diagnostic output.

   %make-void-port

 -- Scheme Procedure: %make-void-port mode
     Create and return a new void port.  A void port acts like
     `/dev/null'.  The MODE argument specifies the input/output modes
     for this port: see the documentation for `open-file' in *note File
     Ports::.

   print-options-interface

 -- Scheme Procedure: print-options-interface [setting]
     Option interface for the print options. Instead of using this
     procedure directly, use the procedures `print-enable',
     `print-disable', `print-set!' and `print-options'.

   simple-format

 -- Scheme Procedure: simple-format destination message . args
     Write MESSAGE to DESTINATION, defaulting to the current output
     port.  MESSAGE can contain `~A' (was `%s') and `~S' (was `%S')
     escapes.  When printed, the escapes are replaced with
     corresponding members of ARGS: `~A' formats using `display' and
     `~S' formats using `write'.  If DESTINATION is `#t', then use the
     current output port, if DESTINATION is `#f', then return a string
     containing the formatted text. Does not add a trailing newline.

   newline

 -- Scheme Procedure: newline [port]
     Send a newline to PORT.  If PORT is omitted, send to the current
     output port.

   write-char

 -- Scheme Procedure: write-char chr [port]
     Send character CHR to PORT.

   port-with-print-state

 -- Scheme Procedure: port-with-print-state port [pstate]
     Create a new port which behaves like PORT, but with an included
     print state PSTATE.  PSTATE is optional.  If PSTATE isn't supplied
     and PORT already has a print state, the old print state is reused.

   get-print-state

 -- Scheme Procedure: get-print-state port
     Return the print state of the port PORT. If PORT has no associated
     print state, `#f' is returned.

   procedure-properties

 -- Scheme Procedure: procedure-properties proc
     Return OBJ's property list.

   set-procedure-properties!

 -- Scheme Procedure: set-procedure-properties! proc new_val
     Set OBJ's property list to ALIST.

   procedure-property

 -- Scheme Procedure: procedure-property p k
     Return the property of OBJ with name KEY.

   set-procedure-property!

 -- Scheme Procedure: set-procedure-property! p k v
     In OBJ's property list, set the property named KEY to VALUE.

   procedure?

 -- Scheme Procedure: procedure? obj
     Return `#t' if OBJ is a procedure.

   closure?

 -- Scheme Procedure: closure? obj
     Return `#t' if OBJ is a closure.

   thunk?

 -- Scheme Procedure: thunk? obj
     Return `#t' if OBJ is a thunk.

   procedure-documentation

 -- Scheme Procedure: procedure-documentation proc
     Return the documentation string associated with `proc'.  By
     convention, if a procedure contains more than one expression and
     the first expression is a string constant, that string is assumed
     to contain documentation for that procedure.

   procedure-with-setter?

 -- Scheme Procedure: procedure-with-setter? obj
     Return `#t' if OBJ is a procedure with an associated setter
     procedure.

   make-procedure-with-setter

 -- Scheme Procedure: make-procedure-with-setter procedure setter
     Create a new procedure which behaves like PROCEDURE, but with the
     associated setter SETTER.

   procedure

 -- Scheme Procedure: procedure proc
     Return the procedure of PROC, which must be either a procedure
     with setter, or an operator struct.

   primitive-make-property

 -- Scheme Procedure: primitive-make-property not_found_proc
     Create a "property token" that can be used with
     `primitive-property-ref' and `primitive-property-set!'.  See
     `primitive-property-ref' for the significance of NOT_FOUND_PROC.

   primitive-property-ref

 -- Scheme Procedure: primitive-property-ref prop obj
     Return the property PROP of OBJ.

     When no value has yet been associated with PROP and OBJ, the
     NOT-FOUND-PROC from PROP is used.  A call `(NOT-FOUND-PROC PROP
     OBJ)' is made and the result set as the property value.  If
     NOT-FOUND-PROC is `#f' then `#f' is the property value.

   primitive-property-set!

 -- Scheme Procedure: primitive-property-set! prop obj val
     Set the property PROP of OBJ to VAL.

   primitive-property-del!

 -- Scheme Procedure: primitive-property-del! prop obj
     Remove any value associated with PROP and OBJ.

   random

 -- Scheme Procedure: random n [state]
     Return a number in [0, N).

     Accepts a positive integer or real n and returns a number of the
     same type between zero (inclusive) and N (exclusive). The values
     returned have a uniform distribution.

     The optional argument STATE must be of the type produced by
     `seed->random-state'. It defaults to the value of the variable
     *RANDOM-STATE*. This object is used to maintain the state of the
     pseudo-random-number generator and is altered as a side effect of
     the random operation.

   copy-random-state

 -- Scheme Procedure: copy-random-state [state]
     Return a copy of the random state STATE.

   seed->random-state

 -- Scheme Procedure: seed->random-state seed
     Return a new random state using SEED.

   random:uniform

 -- Scheme Procedure: random:uniform [state]
     Return a uniformly distributed inexact real random number in [0,1).

   random:normal

 -- Scheme Procedure: random:normal [state]
     Return an inexact real in a normal distribution.  The distribution
     used has mean 0 and standard deviation 1.  For a normal
     distribution with mean m and standard deviation d use `(+ m (* d
     (random:normal)))'.

   random:solid-sphere!

 -- Scheme Procedure: random:solid-sphere! v [state]
     Fills VECT with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of VECT as coordinates in
     space of dimension N = `(vector-length VECT)', the coordinates are
     uniformly distributed within the unit N-sphere.

   random:hollow-sphere!

 -- Scheme Procedure: random:hollow-sphere! v [state]
     Fills vect with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of vect as coordinates in space
     of dimension n = (vector-length vect), the coordinates are
     uniformly distributed over the surface of the unit n-sphere.

   random:normal-vector!

 -- Scheme Procedure: random:normal-vector! v [state]
     Fills vect with inexact real random numbers that are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

   random:exp

 -- Scheme Procedure: random:exp [state]
     Return an inexact real in an exponential distribution with mean 1.
     For an exponential distribution with mean u use (* u (random:exp)).

   %read-delimited!

 -- Scheme Procedure: %read-delimited! delims str gobble [port [start
          [end]]]
     Read characters from PORT into STR until one of the characters in
     the DELIMS string is encountered.  If GOBBLE is true, discard the
     delimiter character; otherwise, leave it in the input stream for
     the next read.  If PORT is not specified, use the value of
     `(current-input-port)'.  If START or END are specified, store data
     only into the substring of STR bounded by START and END (which
     default to the beginning and end of the string, respectively).

     Return a pair consisting of the delimiter that terminated the
     string and the number of characters read.  If reading stopped at
     the end of file, the delimiter returned is the EOF-OBJECT; if the
     string was filled without encountering a delimiter, this value is
     `#f'.

   %read-line

 -- Scheme Procedure: %read-line [port]
     Read a newline-terminated line from PORT, allocating storage as
     necessary.  The newline terminator (if any) is removed from the
     string, and a pair consisting of the line and its delimiter is
     returned.  The delimiter may be either a newline or the
     EOF-OBJECT; if `%read-line' is called at the end of file, it
     returns the pair `(#<eof> . #<eof>)'.

   write-line

 -- Scheme Procedure: write-line obj [port]
     Display OBJ and a newline character to PORT.  If PORT is not
     specified, `(current-output-port)' is used.  This function is
     equivalent to:
          (display obj [port])
          (newline [port])

   read-options-interface

 -- Scheme Procedure: read-options-interface [setting]
     Option interface for the read options. Instead of using this
     procedure directly, use the procedures `read-enable',
     `read-disable', `read-set!' and `read-options'.

   read

 -- Scheme Procedure: read [port]
     Read an s-expression from the input port PORT, or from the current
     input port if PORT is not specified.  Any whitespace before the
     next token is discarded.

   read-hash-extend

 -- Scheme Procedure: read-hash-extend chr proc
     Install the procedure PROC for reading expressions starting with
     the character sequence `#' and CHR.  PROC will be called with two
     arguments:  the character CHR and the port to read further data
     from. The object returned will be the return value of `read'.

   call-with-dynamic-root

 -- Scheme Procedure: call-with-dynamic-root thunk handler
     Call THUNK with a new dynamic state and withina continuation
     barrier.  The HANDLER catches allotherwise uncaught throws and
     executes within the samedynamic context as THUNK.

   dynamic-root

 -- Scheme Procedure: dynamic-root
     Return an object representing the current dynamic root.

     These objects are only useful for comparison using `eq?'.


   read-string!/partial

 -- Scheme Procedure: read-string!/partial str [port_or_fdes [start
          [end]]]
     Read characters from a port or file descriptor into a string STR.
     A port must have an underlying file descriptor -- a so-called
     fport.  This procedure is scsh-compatible and can efficiently read
     large strings.  It will:

        * attempt to fill the entire string, unless the START and/or
          END arguments are supplied.  i.e., START defaults to 0 and
          END defaults to `(string-length str)'

        * use the current input port if PORT_OR_FDES is not supplied.

        * return fewer than the requested number of characters in some
          cases, e.g., on end of file, if interrupted by a signal, or if
          not all the characters are immediately available.

        * wait indefinitely for some input if no characters are
          currently available, unless the port is in non-blocking mode.

        * read characters from the port's input buffers if available,
          instead from the underlying file descriptor.

        * return `#f' if end-of-file is encountered before reading any
          characters, otherwise return the number of characters read.

        * return 0 if the port is in non-blocking mode and no characters
          are immediately available.

        * return 0 if the request is for 0 bytes, with no end-of-file
          check.

   write-string/partial

 -- Scheme Procedure: write-string/partial str [port_or_fdes [start
          [end]]]
     Write characters from a string STR to a port or file descriptor.
     A port must have an underlying file descriptor -- a so-called
     fport.  This procedure is scsh-compatible and can efficiently
     write large strings.  It will:

        * attempt to write the entire string, unless the START and/or
          END arguments are supplied.  i.e., START defaults to 0 and
          END defaults to `(string-length str)'

        * use the current output port if PORT_OF_FDES is not supplied.

        * in the case of a buffered port, store the characters in the
          port's output buffer, if all will fit.  If they will not fit
          then any existing buffered characters will be flushed before
          attempting to write the new characters directly to the
          underlying file descriptor.  If the port is in non-blocking
          mode and buffered characters can not be flushed immediately,
          then an `EAGAIN' system-error exception will be raised (Note:
          scsh does not support the use of non-blocking buffered ports.)

        * write fewer than the requested number of characters in some
          cases, e.g., if interrupted by a signal or if not all of the
          output can be accepted immediately.

        * wait indefinitely for at least one character from STR to be
          accepted by the port, unless the port is in non-blocking mode.

        * return the number of characters accepted by the port.

        * return 0 if the port is in non-blocking mode and can not
          accept at least one character from STR immediately

        * return 0 immediately if the request size is 0 bytes.

   sigaction

 -- Scheme Procedure: sigaction signum [handler [flags [thread]]]
     Install or report the signal handler for a specified signal.

     SIGNUM is the signal number, which can be specified using the value
     of variables such as `SIGINT'.

     If HANDLER is omitted, `sigaction' returns a pair: the CAR is the
     current signal hander, which will be either an integer with the
     value `SIG_DFL' (default action) or `SIG_IGN' (ignore), or the
     Scheme procedure which handles the signal, or `#f' if a non-Scheme
     procedure handles the signal.  The CDR contains the current
     `sigaction' flags for the handler.

     If HANDLER is provided, it is installed as the new handler for
     SIGNUM.  HANDLER can be a Scheme procedure taking one argument, or
     the value of `SIG_DFL' (default action) or `SIG_IGN' (ignore), or
     `#f' to restore whatever signal handler was installed before
     `sigaction' was first used.  When a scheme procedure has been
     specified, that procedure will run in the given THREAD.   When no
     thread has been given, the thread that made this call to
     `sigaction' is used.  Flags can optionally be specified for the
     new handler.  The return value is a pair with information about the
     old handler as described above.

     This interface does not provide access to the "signal blocking"
     facility.  Maybe this is not needed, since the thread support may
     provide solutions to the problem of consistent access to data
     structures.

   restore-signals

 -- Scheme Procedure: restore-signals
     Return all signal handlers to the values they had before any call
     to `sigaction' was made.  The return value is unspecified.

   alarm

 -- Scheme Procedure: alarm i
     Set a timer to raise a `SIGALRM' signal after the specified number
     of seconds (an integer).  It's advisable to install a signal
     handler for `SIGALRM' beforehand, since the default action is to
     terminate the process.

     The return value indicates the time remaining for the previous
     alarm, if any.  The new value replaces the previous alarm.  If
     there was no previous alarm, the return value is zero.

   setitimer

 -- Scheme Procedure: setitimer which_timer interval_seconds
          interval_microseconds value_seconds value_microseconds
     Set the timer specified by WHICH_TIMER according to the given
     INTERVAL_SECONDS, INTERVAL_MICROSECONDS, VALUE_SECONDS, and
     VALUE_MICROSECONDS values.

     Return information about the timer's previous setting.  Errors are
     handled as described in the guile info pages under "POSIX
     Interface Conventions".

     The timers available are: `ITIMER_REAL', `ITIMER_VIRTUAL', and
     `ITIMER_PROF'.

     The return value will be a list of two cons pairs representing the
     current state of the given timer.  The first pair is the seconds
     and microseconds of the timer `it_interval', and the second pair is
     the seconds and microseconds of the timer `it_value'.

   getitimer

 -- Scheme Procedure: getitimer which_timer
     Return information about the timer specified by WHICH_TIMER Errors
     are handled as described in the guile info pages under "POSIX
     Interface Conventions".

     The timers available are: `ITIMER_REAL', `ITIMER_VIRTUAL', and
     `ITIMER_PROF'.

     The return value will be a list of two cons pairs representing the
     current state of the given timer.  The first pair is the seconds
     and microseconds of the timer `it_interval', and the second pair is
     the seconds and microseconds of the timer `it_value'.

   pause

 -- Scheme Procedure: pause
     Pause the current process (thread?) until a signal arrives whose
     action is to either terminate the current process or invoke a
     handler procedure.  The return value is unspecified.

   sleep

 -- Scheme Procedure: sleep i
     Wait for the given number of seconds (an integer) or until a signal
     arrives.  The return value is zero if the time elapses or the
     number of seconds remaining otherwise.

     See also `usleep'.

   usleep

 -- Scheme Procedure: usleep i
     Wait the given period USECS microseconds (an integer).  If a
     signal arrives the wait stops and the return value is the time
     remaining, in microseconds.  If the period elapses with no signal
     the return is zero.

     On most systems the process scheduler is not microsecond accurate
     and the actual period slept by `usleep' may be rounded to a system
     clock tick boundary.  Traditionally such ticks were 10 milliseconds
     apart, and that interval is often still used.

     See also `sleep'.

   raise

 -- Scheme Procedure: raise sig
     Sends a specified signal SIG to the current process, where SIG is
     as described for the kill procedure.

   system

 -- Scheme Procedure: system [cmd]
     Execute CMD using the operating system's "command processor".
     Under Unix this is usually the default shell `sh'.  The value
     returned is CMD's exit status as returned by `waitpid', which can
     be interpreted using `status:exit-val' and friends.

     If `system' is called without arguments, return a boolean
     indicating whether the command processor is available.

   system*

 -- Scheme Procedure: system* . args
     Execute the command indicated by ARGS.  The first element must be
     a string indicating the command to be executed, and the remaining
     items must be strings representing each of the arguments to that
     command.

     This function returns the exit status of the command as provided by
     `waitpid'.  This value can be handled with `status:exit-val' and
     the related functions.

     `system*' is similar to `system', but accepts only one string
     per-argument, and performs no shell interpretation.  The command
     is executed using fork and execlp.  Accordingly this function may
     be safer than `system' in situations where shell interpretation is
     not required.

     Example: (system* "echo" "foo" "bar")

   getenv

 -- Scheme Procedure: getenv nam
     Looks up the string NAME in the current environment.  The return
     value is `#f' unless a string of the form `NAME=VALUE' is found,
     in which case the string `VALUE' is returned.

   primitive-exit

 -- Scheme Procedure: primitive-exit [status]
     Terminate the current process without unwinding the Scheme stack.
     The exit status is STATUS if supplied, otherwise zero.

   primitive-_exit

 -- Scheme Procedure: primitive-_exit [status]
     Terminate the current process using the _exit() system call and
     without unwinding the Scheme stack.  The exit status is STATUS if
     supplied, otherwise zero.

     This function is typically useful after a fork, to ensure no
     Scheme cleanups or `atexit' handlers are run (those usually
     belonging in the parent rather than the child).

   restricted-vector-sort!

 -- Scheme Procedure: restricted-vector-sort! vec less startpos endpos
     Sort the vector VEC, using LESS for comparing the vector elements.
     STARTPOS (inclusively) and ENDPOS (exclusively) delimit the range
     of the vector which gets sorted.  The return value is not
     specified.

   sorted?

 -- Scheme Procedure: sorted? items less
     Return `#t' iff ITEMS is a list or a vector such that for all 1 <=
     i <= m, the predicate LESS returns true when applied to all
     elements i - 1 and i

   merge

 -- Scheme Procedure: merge alist blist less
     Merge two already sorted lists into one.  Given two lists ALIST
     and BLIST, such that `(sorted? alist less?)' and `(sorted? blist
     less?)', return a new list in which the elements of ALIST and
     BLIST have been stably interleaved so that `(sorted? (merge alist
     blist less?) less?)'.  Note:  this does _not_ accept vectors.

   merge!

 -- Scheme Procedure: merge! alist blist less
     Takes two lists ALIST and BLIST such that `(sorted? alist less?)'
     and `(sorted? blist less?)' and returns a new list in which the
     elements of ALIST and BLIST have been stably interleaved so that
     `(sorted? (merge alist blist less?) less?)'.  This is the
     destructive variant of `merge' Note:  this does _not_ accept
     vectors.

   sort!

 -- Scheme Procedure: sort! items less
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  The sorting is
     destructive, that means that the input sequence is modified to
     produce the sorted result.  This is not a stable sort.

   sort

 -- Scheme Procedure: sort items less
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  This is not a stable
     sort.

   stable-sort!

 -- Scheme Procedure: stable-sort! items less
     Sort the sequence ITEMS, which may be a list or a vector. LESS is
     used for comparing the sequence elements.  The sorting is
     destructive, that means that the input sequence is modified to
     produce the sorted result.  This is a stable sort.

   stable-sort

 -- Scheme Procedure: stable-sort items less
     Sort the sequence ITEMS, which may be a list or a vector. LESS is
     used for comparing the sequence elements.  This is a stable sort.

   sort-list!

 -- Scheme Procedure: sort-list! items less
     Sort the list ITEMS, using LESS for comparing the list elements.
     The sorting is destructive, that means that the input list is
     modified to produce the sorted result.  This is a stable sort.

   sort-list

 -- Scheme Procedure: sort-list items less
     Sort the list ITEMS, using LESS for comparing the list elements.
     This is a stable sort.

   source-properties

 -- Scheme Procedure: source-properties obj
     Return the source property association list of OBJ.

   set-source-properties!

 -- Scheme Procedure: set-source-properties! obj plist
     Install the association list PLIST as the source property list for
     OBJ.

   source-property

 -- Scheme Procedure: source-property obj key
     Return the source property specified by KEY from OBJ's source
     property list.

   set-source-property!

 -- Scheme Procedure: set-source-property! obj key datum
     Set the source property of object OBJ, which is specified by KEY
     to DATUM.  Normally, the key will be a symbol.

   %get-stack-size

 -- Scheme Procedure: %get-stack-size
     Return the current thread's C stack size (in Scheme objects).

   stack?

 -- Scheme Procedure: stack? obj
     Return `#t' if OBJ is a calling stack.

   make-stack

 -- Scheme Procedure: make-stack obj . args
     Create a new stack. If OBJ is `#t', the current evaluation stack
     is used for creating the stack frames, otherwise the frames are
     taken from OBJ (which must be either a debug object or a
     continuation).

     ARGS should be a list containing any combination of integer,
     procedure and `#t' values.

     These values specify various ways of cutting away uninteresting
     stack frames from the top and bottom of the stack that
     `make-stack' returns.  They come in pairs like this: `(INNER_CUT_1
     OUTER_CUT_1 INNER_CUT_2 OUTER_CUT_2 ...)'.

     Each INNER_CUT_N can be `#t', an integer, or a procedure.  `#t'
     means to cut away all frames up to but excluding the first user
     module frame.  An integer means to cut away exactly that number of
     frames.  A procedure means to cut away all frames up to but
     excluding the application frame whose procedure matches the
     specified one.

     Each OUTER_CUT_N can be an integer or a procedure.  An integer
     means to cut away that number of frames.  A procedure means to cut
     away frames down to but excluding the application frame whose
     procedure matches the specified one.

     If the OUTER_CUT_N of the last pair is missing, it is taken as 0.

   stack-id

 -- Scheme Procedure: stack-id stack
     Return the identifier given to STACK by `start-stack'.

   stack-ref

 -- Scheme Procedure: stack-ref stack index
     Return the INDEX'th frame from STACK.

   stack-length

 -- Scheme Procedure: stack-length stack
     Return the length of STACK.

   frame?

 -- Scheme Procedure: frame? obj
     Return `#t' if OBJ is a stack frame.

   last-stack-frame

 -- Scheme Procedure: last-stack-frame obj
     Return a stack which consists of a single frame, which is the last
     stack frame for OBJ. OBJ must be either a debug object or a
     continuation.

   frame-number

 -- Scheme Procedure: frame-number frame
     Return the frame number of FRAME.

   frame-source

 -- Scheme Procedure: frame-source frame
     Return the source of FRAME.

   frame-procedure

 -- Scheme Procedure: frame-procedure frame
     Return the procedure for FRAME, or `#f' if no procedure is
     associated with FRAME.

   frame-arguments

 -- Scheme Procedure: frame-arguments frame
     Return the arguments of FRAME.

   frame-previous

 -- Scheme Procedure: frame-previous frame
     Return the previous frame of FRAME, or `#f' if FRAME is the first
     frame in its stack.

   frame-next

 -- Scheme Procedure: frame-next frame
     Return the next frame of FRAME, or `#f' if FRAME is the last frame
     in its stack.

   frame-real?

 -- Scheme Procedure: frame-real? frame
     Return `#t' if FRAME is a real frame.

   frame-procedure?

 -- Scheme Procedure: frame-procedure? frame
     Return `#t' if a procedure is associated with FRAME.

   frame-evaluating-args?

 -- Scheme Procedure: frame-evaluating-args? frame
     Return `#t' if FRAME contains evaluated arguments.

   frame-overflow?

 -- Scheme Procedure: frame-overflow? frame
     Return `#t' if FRAME is an overflow frame.

   get-internal-real-time

 -- Scheme Procedure: get-internal-real-time
     Return the number of time units since the interpreter was started.

   times

 -- Scheme Procedure: times
     Return an object with information about real and processor time.
     The following procedures accept such an object as an argument and
     return a selected component:

    `tms:clock'
          The current real time, expressed as time units relative to an
          arbitrary base.

    `tms:utime'
          The CPU time units used by the calling process.

    `tms:stime'
          The CPU time units used by the system on behalf of the calling
          process.

    `tms:cutime'
          The CPU time units used by terminated child processes of the
          calling process, whose status has been collected (e.g., using
          `waitpid').

    `tms:cstime'
          Similarly, the CPU times units used by the system on behalf of
          terminated child processes.

   get-internal-run-time

 -- Scheme Procedure: get-internal-run-time
     Return the number of time units of processor time used by the
     interpreter.  Both _system_ and _user_ time are included but
     subprocesses are not.

   current-time

 -- Scheme Procedure: current-time
     Return the number of seconds since 1970-01-01 00:00:00 UTC,
     excluding leap seconds.

   gettimeofday

 -- Scheme Procedure: gettimeofday
     Return a pair containing the number of seconds and microseconds
     since 1970-01-01 00:00:00 UTC, excluding leap seconds.  Note:
     whether true microsecond resolution is available depends on the
     operating system.

   localtime

 -- Scheme Procedure: localtime time [zone]
     Return an object representing the broken down components of TIME,
     an integer like the one returned by `current-time'.  The time zone
     for the calculation is optionally specified by ZONE (a string),
     otherwise the `TZ' environment variable or the system default is
     used.

   gmtime

 -- Scheme Procedure: gmtime time
     Return an object representing the broken down components of TIME,
     an integer like the one returned by `current-time'.  The values
     are calculated for UTC.

   mktime

 -- Scheme Procedure: mktime sbd_time [zone]
     BD-TIME is an object representing broken down time and `zone' is
     an optional time zone specifier (otherwise the TZ environment
     variable or the system default is used).

     Returns a pair: the car is a corresponding integer time value like
     that returned by `current-time'; the cdr is a broken down time
     object, similar to as BD-TIME but with normalized values.

   tzset

 -- Scheme Procedure: tzset
     Initialize the timezone from the TZ environment variable or the
     system default.  It's not usually necessary to call this procedure
     since it's done automatically by other procedures that depend on
     the timezone.

   strftime

 -- Scheme Procedure: strftime format stime
     Return a string which is broken-down time structure STIME
     formatted according to the given FORMAT string.

     FORMAT contains field specifications introduced by a `%'
     character.  See *note Formatting Calendar Time: (libc)Formatting
     Calendar Time, or `man 3 strftime', for the available formatting.

          (strftime "%c" (localtime (current-time)))
          => "Mon Mar 11 20:17:43 2002"

     If `setlocale' has been called (*note Locales::), month and day
     names are from the current locale and in the locale character set.

   string?

 -- Scheme Procedure: string? obj
     Return `#t' if OBJ is a string, else `#f'.

   list->string

 -- Scheme Procedure: list->string
     implemented by the C function "scm_string"

   string

 -- Scheme Procedure: string . chrs
 -- Scheme Procedure: list->string chrs
     Return a newly allocated string composed of the arguments, CHRS.

   make-string

 -- Scheme Procedure: make-string k [chr]
     Return a newly allocated string of length K.  If CHR is given,
     then all elements of the string are initialized to CHR, otherwise
     the contents of the STRING are unspecified.

   string-length

 -- Scheme Procedure: string-length string
     Return the number of characters in STRING.

   string-ref

 -- Scheme Procedure: string-ref str k
     Return character K of STR using zero-origin indexing. K must be a
     valid index of STR.

   string-set!

 -- Scheme Procedure: string-set! str k chr
     Store CHR in element K of STR and return an unspecified value. K
     must be a valid index of STR.

   substring

 -- Scheme Procedure: substring str start [end]
     Return a newly allocated string formed from the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

   substring/read-only

 -- Scheme Procedure: substring/read-only str start [end]
     Return a newly allocated string formed from the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

     The returned string is read-only.


   substring/copy

 -- Scheme Procedure: substring/copy str start [end]
     Return a newly allocated string formed from the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

   substring/shared

 -- Scheme Procedure: substring/shared str start [end]
     Return string that indirectly refers to the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

   string-append

 -- Scheme Procedure: string-append . args
     Return a newly allocated string whose characters form the
     concatenation of the given strings, ARGS.

   uniform-vector?

 -- Scheme Procedure: uniform-vector? obj
     Return `#t' if OBJ is a uniform vector.

   uniform-vector-ref

 -- Scheme Procedure: uniform-vector-ref v idx
     Return the element at index IDX of the homogenous numeric vector V.

   uniform-vector-set!

 -- Scheme Procedure: uniform-vector-set! v idx val
     Set the element at index IDX of the homogenous numeric vector V to
     VAL.

   uniform-vector->list

 -- Scheme Procedure: uniform-vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   uniform-vector-length

 -- Scheme Procedure: uniform-vector-length v
     Return the number of elements in the uniform vector V.

   uniform-vector-read!

 -- Scheme Procedure: uniform-vector-read! uvec [port_or_fd [start
          [end]]]
     Fill the elements of UVEC by reading raw bytes from PORT-OR-FDES,
     using host byte order.

     The optional arguments START (inclusive) and END (exclusive) allow
     a specified region to be read, leaving the remainder of the vector
     unchanged.

     When PORT-OR-FDES is a port, all specified elements of UVEC are
     attempted to be read, potentially blocking while waiting formore
     input or end-of-file.  When PORT-OR-FD is an integer, a single
     call to read(2) is made.

     An error is signalled when the last element has only been
     partially filled before reaching end-of-file or in the single call
     to read(2).

     `uniform-vector-read!' returns the number of elements read.

     PORT-OR-FDES may be omitted, in which case it defaults to the
     value returned by `(current-input-port)'.

   uniform-vector-write

 -- Scheme Procedure: uniform-vector-write uvec [port_or_fd [start
          [end]]]
     Write the elements of UVEC as raw bytes to PORT-OR-FDES, in the
     host byte order.

     The optional arguments START (inclusive) and END (exclusive) allow
     a specified region to be written.

     When PORT-OR-FDES is a port, all specified elements of UVEC are
     attempted to be written, potentially blocking while waiting for
     more room.  When PORT-OR-FD is an integer, a single call to
     write(2) is made.

     An error is signalled when the last element has only been
     partially written in the single call to write(2).

     The number of objects actually written is returned.  PORT-OR-FDES
     may be omitted, in which case it defaults to the value returned by
     `(current-output-port)'.

   u8vector?

 -- Scheme Procedure: u8vector? obj
     Return `#t' if OBJ is a vector of type u8, `#f' otherwise.

   make-u8vector

 -- Scheme Procedure: make-u8vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   u8vector

 -- Scheme Procedure: u8vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   u8vector-length

 -- Scheme Procedure: u8vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   u8vector-ref

 -- Scheme Procedure: u8vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   u8vector-set!

 -- Scheme Procedure: u8vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   u8vector->list

 -- Scheme Procedure: u8vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->u8vector

 -- Scheme Procedure: list->u8vector l
     Convert the list L to a numeric uniform vector.

   any->u8vector

 -- Scheme Procedure: any->u8vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type u8.

   s8vector?

 -- Scheme Procedure: s8vector? obj
     Return `#t' if OBJ is a vector of type s8, `#f' otherwise.

   make-s8vector

 -- Scheme Procedure: make-s8vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   s8vector

 -- Scheme Procedure: s8vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   s8vector-length

 -- Scheme Procedure: s8vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   s8vector-ref

 -- Scheme Procedure: s8vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   s8vector-set!

 -- Scheme Procedure: s8vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   s8vector->list

 -- Scheme Procedure: s8vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->s8vector

 -- Scheme Procedure: list->s8vector l
     Convert the list L to a numeric uniform vector.

   any->s8vector

 -- Scheme Procedure: any->s8vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type s8.

   u16vector?

 -- Scheme Procedure: u16vector? obj
     Return `#t' if OBJ is a vector of type u16, `#f' otherwise.

   make-u16vector

 -- Scheme Procedure: make-u16vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   u16vector

 -- Scheme Procedure: u16vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   u16vector-length

 -- Scheme Procedure: u16vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   u16vector-ref

 -- Scheme Procedure: u16vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   u16vector-set!

 -- Scheme Procedure: u16vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   u16vector->list

 -- Scheme Procedure: u16vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->u16vector

 -- Scheme Procedure: list->u16vector l
     Convert the list L to a numeric uniform vector.

   any->u16vector

 -- Scheme Procedure: any->u16vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type u16.

   s16vector?

 -- Scheme Procedure: s16vector? obj
     Return `#t' if OBJ is a vector of type s16, `#f' otherwise.

   make-s16vector

 -- Scheme Procedure: make-s16vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   s16vector

 -- Scheme Procedure: s16vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   s16vector-length

 -- Scheme Procedure: s16vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   s16vector-ref

 -- Scheme Procedure: s16vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   s16vector-set!

 -- Scheme Procedure: s16vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   s16vector->list

 -- Scheme Procedure: s16vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->s16vector

 -- Scheme Procedure: list->s16vector l
     Convert the list L to a numeric uniform vector.

   any->s16vector

 -- Scheme Procedure: any->s16vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type s16.

   u32vector?

 -- Scheme Procedure: u32vector? obj
     Return `#t' if OBJ is a vector of type u32, `#f' otherwise.

   make-u32vector

 -- Scheme Procedure: make-u32vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   u32vector

 -- Scheme Procedure: u32vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   u32vector-length

 -- Scheme Procedure: u32vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   u32vector-ref

 -- Scheme Procedure: u32vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   u32vector-set!

 -- Scheme Procedure: u32vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   u32vector->list

 -- Scheme Procedure: u32vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->u32vector

 -- Scheme Procedure: list->u32vector l
     Convert the list L to a numeric uniform vector.

   any->u32vector

 -- Scheme Procedure: any->u32vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type u32.

   s32vector?

 -- Scheme Procedure: s32vector? obj
     Return `#t' if OBJ is a vector of type s32, `#f' otherwise.

   make-s32vector

 -- Scheme Procedure: make-s32vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   s32vector

 -- Scheme Procedure: s32vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   s32vector-length

 -- Scheme Procedure: s32vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   s32vector-ref

 -- Scheme Procedure: s32vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   s32vector-set!

 -- Scheme Procedure: s32vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   s32vector->list

 -- Scheme Procedure: s32vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->s32vector

 -- Scheme Procedure: list->s32vector l
     Convert the list L to a numeric uniform vector.

   any->s32vector

 -- Scheme Procedure: any->s32vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type s32.

   u64vector?

 -- Scheme Procedure: u64vector? obj
     Return `#t' if OBJ is a vector of type u64, `#f' otherwise.

   make-u64vector

 -- Scheme Procedure: make-u64vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   u64vector

 -- Scheme Procedure: u64vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   u64vector-length

 -- Scheme Procedure: u64vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   u64vector-ref

 -- Scheme Procedure: u64vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   u64vector-set!

 -- Scheme Procedure: u64vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   u64vector->list

 -- Scheme Procedure: u64vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->u64vector

 -- Scheme Procedure: list->u64vector l
     Convert the list L to a numeric uniform vector.

   any->u64vector

 -- Scheme Procedure: any->u64vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type u64.

   s64vector?

 -- Scheme Procedure: s64vector? obj
     Return `#t' if OBJ is a vector of type s64, `#f' otherwise.

   make-s64vector

 -- Scheme Procedure: make-s64vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   s64vector

 -- Scheme Procedure: s64vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   s64vector-length

 -- Scheme Procedure: s64vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   s64vector-ref

 -- Scheme Procedure: s64vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   s64vector-set!

 -- Scheme Procedure: s64vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   s64vector->list

 -- Scheme Procedure: s64vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->s64vector

 -- Scheme Procedure: list->s64vector l
     Convert the list L to a numeric uniform vector.

   any->s64vector

 -- Scheme Procedure: any->s64vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type s64.

   f32vector?

 -- Scheme Procedure: f32vector? obj
     Return `#t' if OBJ is a vector of type f32, `#f' otherwise.

   make-f32vector

 -- Scheme Procedure: make-f32vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   f32vector

 -- Scheme Procedure: f32vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   f32vector-length

 -- Scheme Procedure: f32vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   f32vector-ref

 -- Scheme Procedure: f32vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   f32vector-set!

 -- Scheme Procedure: f32vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   f32vector->list

 -- Scheme Procedure: f32vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->f32vector

 -- Scheme Procedure: list->f32vector l
     Convert the list L to a numeric uniform vector.

   any->f32vector

 -- Scheme Procedure: any->f32vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type f32.

   f64vector?

 -- Scheme Procedure: f64vector? obj
     Return `#t' if OBJ is a vector of type f64, `#f' otherwise.

   make-f64vector

 -- Scheme Procedure: make-f64vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   f64vector

 -- Scheme Procedure: f64vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   f64vector-length

 -- Scheme Procedure: f64vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   f64vector-ref

 -- Scheme Procedure: f64vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   f64vector-set!

 -- Scheme Procedure: f64vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   f64vector->list

 -- Scheme Procedure: f64vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->f64vector

 -- Scheme Procedure: list->f64vector l
     Convert the list L to a numeric uniform vector.

   any->f64vector

 -- Scheme Procedure: any->f64vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type f64.

   c32vector?

 -- Scheme Procedure: c32vector? obj
     Return `#t' if OBJ is a vector of type c32, `#f' otherwise.

   make-c32vector

 -- Scheme Procedure: make-c32vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   c32vector

 -- Scheme Procedure: c32vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   c32vector-length

 -- Scheme Procedure: c32vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   c32vector-ref

 -- Scheme Procedure: c32vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   c32vector-set!

 -- Scheme Procedure: c32vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   c32vector->list

 -- Scheme Procedure: c32vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->c32vector

 -- Scheme Procedure: list->c32vector l
     Convert the list L to a numeric uniform vector.

   any->c32vector

 -- Scheme Procedure: any->c32vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type c32.

   c64vector?

 -- Scheme Procedure: c64vector? obj
     Return `#t' if OBJ is a vector of type c64, `#f' otherwise.

   make-c64vector

 -- Scheme Procedure: make-c64vector len [fill]
     Return a newly allocated uniform numeric vector which can hold LEN
     elements.  If FILL is given, it is used to initialize the
     elements, otherwise the contents of the vector is unspecified.

   c64vector

 -- Scheme Procedure: c64vector . l
     Return a newly allocated uniform numeric vector containing all
     argument values.

   c64vector-length

 -- Scheme Procedure: c64vector-length uvec
     Return the number of elements in the uniform numeric vector UVEC.

   c64vector-ref

 -- Scheme Procedure: c64vector-ref uvec index
     Return the element at INDEX in the uniform numeric vector UVEC.

   c64vector-set!

 -- Scheme Procedure: c64vector-set! uvec index value
     Set the element at INDEX in the uniform numeric vector UVEC to
     VALUE.  The return value is not specified.

   c64vector->list

 -- Scheme Procedure: c64vector->list uvec
     Convert the uniform numeric vector UVEC to a list.

   list->c64vector

 -- Scheme Procedure: list->c64vector l
     Convert the list L to a numeric uniform vector.

   any->c64vector

 -- Scheme Procedure: any->c64vector obj
     Convert OBJ, which can be a list, vector, or uniform vector, to a
     numeric uniform vector of type c64.

   string-null?

 -- Scheme Procedure: string-null? str
     Return `#t' if STR's length is zero, and `#f' otherwise.
          (string-null? "")  => #t
          y                    => "foo"
          (string-null? y)     => #f

   string-any-c-code

 -- Scheme Procedure: string-any-c-code char_pred s [start [end]]
     Check if CHAR_PRED is true for any character in string S.

     CHAR_PRED can be a character to check for any equal to that, or a
     character set (*note Character Sets::) to check for any in that
     set, or a predicate procedure to call.

     For a procedure, calls `(CHAR_PRED c)' are made successively on
     the characters from START to END.  If CHAR_PRED returns true (ie.
     non-`#f'), `string-any' stops and that return value is the return
     from `string-any'.  The call on the last character (ie. at END-1),
     if that point is reached, is a tail call.

     If there are no characters in S (ie. START equals END) then the
     return is `#f'.


   string-every-c-code

 -- Scheme Procedure: string-every-c-code char_pred s [start [end]]
     Check if CHAR_PRED is true for every character in string S.

     CHAR_PRED can be a character to check for every character equal to
     that, or a character set (*note Character Sets::) to check for
     every character being in that set, or a predicate procedure to
     call.

     For a procedure, calls `(CHAR_PRED c)' are made successively on
     the characters from START to END.  If CHAR_PRED returns `#f',
     `string-every' stops and returns `#f'.  The call on the last
     character (ie. at END-1), if that point is reached, is a tail call
     and the return from that call is the return from `string-every'.

     If there are no characters in S (ie. START equals END) then the
     return is `#t'.


   string-tabulate

 -- Scheme Procedure: string-tabulate proc len
     PROC is an integer->char procedure.  Construct a string of size
     LEN by applying PROC to each index to produce the corresponding
     string element.  The order in which PROC is applied to the indices
     is not specified.

   string->list

 -- Scheme Procedure: string->list str [start [end]]
     Convert the string STR into a list of characters.

   reverse-list->string

 -- Scheme Procedure: reverse-list->string chrs
     An efficient implementation of `(compose string->list reverse)':

          (reverse-list->string '(#\a #\B #\c)) => "cBa"

   string-join

 -- Scheme Procedure: string-join ls [delimiter [grammar]]
     Append the string in the string list LS, using the string DELIM as
     a delimiter between the elements of LS.  GRAMMAR is a symbol which
     specifies how the delimiter is placed between the strings, and
     defaults to the symbol `infix'.

    `infix'
          Insert the separator between list elements.  An empty string
          will produce an empty list.

    `string-infix'
          Like `infix', but will raise an error if given the empty list.

    `suffix'
          Insert the separator after every list element.

    `prefix'
          Insert the separator before each list element.

   string-copy

 -- Scheme Procedure: string-copy str [start [end]]
     Return a freshly allocated copy of the string STR.  If given,
     START and END delimit the portion of STR which is copied.

   string-copy!

 -- Scheme Procedure: string-copy! target tstart s [start [end]]
     Copy the sequence of characters from index range [START, END) in
     string S to string TARGET, beginning at index TSTART.  The
     characters are copied left-to-right or right-to-left as needed -
     the copy is guaranteed to work, even if TARGET and S are the same
     string.  It is an error if the copy operation runs off the end of
     the target string.

   substring-move!

 -- Scheme Procedure: substring-move! str1 start1 end1 str2 start2
     Copy the substring of STR1 bounded by START1 and END1 into STR2
     beginning at position START2.  STR1 and STR2 can be the same
     string.

   string-take

 -- Scheme Procedure: string-take s n
     Return the N first characters of S.

   string-drop

 -- Scheme Procedure: string-drop s n
     Return all but the first N characters of S.

   string-take-right

 -- Scheme Procedure: string-take-right s n
     Return the N last characters of S.

   string-drop-right

 -- Scheme Procedure: string-drop-right s n
     Return all but the last N characters of S.

   string-pad

 -- Scheme Procedure: string-pad s len [chr [start [end]]]
     Take that characters from START to END from the string S and
     return a new string, right-padded by the character CHR to length
     LEN.  If the resulting string is longer than LEN, it is truncated
     on the right.

   string-pad-right

 -- Scheme Procedure: string-pad-right s len [chr [start [end]]]
     Take that characters from START to END from the string S and
     return a new string, left-padded by the character CHR to length
     LEN.  If the resulting string is longer than LEN, it is truncated
     on the left.

   string-trim

 -- Scheme Procedure: string-trim s [char_pred [start [end]]]
     Trim S by skipping over all characters on the left that satisfy
     the parameter CHAR_PRED:

        * if it is the character CH, characters equal to CH are trimmed,

        * if it is a procedure PRED characters that satisfy PRED are
          trimmed,

        * if it is a character set, characters in that set are trimmed.

     If called without a CHAR_PRED argument, all whitespace is trimmed.

   string-trim-right

 -- Scheme Procedure: string-trim-right s [char_pred [start [end]]]
     Trim S by skipping over all characters on the rightt that satisfy
     the parameter CHAR_PRED:

        * if it is the character CH, characters equal to CH are trimmed,

        * if it is a procedure PRED characters that satisfy PRED are
          trimmed,

        * if it is a character sets, all characters in that set are
          trimmed.

     If called without a CHAR_PRED argument, all whitespace is trimmed.

   string-trim-both

 -- Scheme Procedure: string-trim-both s [char_pred [start [end]]]
     Trim S by skipping over all characters on both sides of the string
     that satisfy the parameter CHAR_PRED:

        * if it is the character CH, characters equal to CH are trimmed,

        * if it is a procedure PRED characters that satisfy PRED are
          trimmed,

        * if it is a character set, the characters in the set are
          trimmed.

     If called without a CHAR_PRED argument, all whitespace is trimmed.

   string-fill!

 -- Scheme Procedure: string-fill! str chr [start [end]]
     Stores CHR in every element of the given STR and returns an
     unspecified value.

   string-compare

 -- Scheme Procedure: string-compare s1 s2 proc_lt proc_eq proc_gt
          [start1 [end1 [start2 [end2]]]]
     Apply PROC_LT, PROC_EQ, PROC_GT to the mismatch index, depending
     upon whether S1 is less than, equal to, or greater than S2.  The
     mismatch index is the largest index I such that for every 0 <= J <
     I, S1[J] = S2[J] - that is, I is the first position that does not
     match.

   string-compare-ci

 -- Scheme Procedure: string-compare-ci s1 s2 proc_lt proc_eq proc_gt
          [start1 [end1 [start2 [end2]]]]
     Apply PROC_LT, PROC_EQ, PROC_GT to the mismatch index, depending
     upon whether S1 is less than, equal to, or greater than S2.  The
     mismatch index is the largest index I such that for every 0 <= J <
     I, S1[J] = S2[J] - that is, I is the first position that does not
     match.  The character comparison is done case-insensitively.

   string=

 -- Scheme Procedure: string= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 and S2 are not equal, a true value otherwise.

   string<>

 -- Scheme Procedure: string<> s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 and S2 are equal, a true value otherwise.

   string<

 -- Scheme Procedure: string< s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is greater or equal to S2, a true value
     otherwise.

   string>

 -- Scheme Procedure: string> s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is less or equal to S2, a true value otherwise.

   string<=

 -- Scheme Procedure: string<= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is greater to S2, a true value otherwise.

   string>=

 -- Scheme Procedure: string>= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is less to S2, a true value otherwise.

   string-ci=

 -- Scheme Procedure: string-ci= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 and S2 are not equal, a true value otherwise.
     The character comparison is done case-insensitively.

   string-ci<>

 -- Scheme Procedure: string-ci<> s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 and S2 are equal, a true value otherwise.  The
     character comparison is done case-insensitively.

   string-ci<

 -- Scheme Procedure: string-ci< s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is greater or equal to S2, a true value
     otherwise.  The character comparison is done case-insensitively.

   string-ci>

 -- Scheme Procedure: string-ci> s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is less or equal to S2, a true value otherwise.
     The character comparison is done case-insensitively.

   string-ci<=

 -- Scheme Procedure: string-ci<= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is greater to S2, a true value otherwise.  The
     character comparison is done case-insensitively.

   string-ci>=

 -- Scheme Procedure: string-ci>= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is less to S2, a true value otherwise.  The
     character comparison is done case-insensitively.

   string-hash

 -- Scheme Procedure: string-hash s [bound [start [end]]]
     Compute a hash value for S.  the optional argument BOUND is a
     non-negative exact integer specifying the range of the hash
     function. A positive value restricts the return value to the range
     [0,bound).

   string-hash-ci

 -- Scheme Procedure: string-hash-ci s [bound [start [end]]]
     Compute a hash value for S.  the optional argument BOUND is a
     non-negative exact integer specifying the range of the hash
     function. A positive value restricts the return value to the range
     [0,bound).

   string-prefix-length

 -- Scheme Procedure: string-prefix-length s1 s2 [start1 [end1 [start2
          [end2]]]]
     Return the length of the longest common prefix of the two strings.

   string-prefix-length-ci

 -- Scheme Procedure: string-prefix-length-ci s1 s2 [start1 [end1
          [start2 [end2]]]]
     Return the length of the longest common prefix of the two strings,
     ignoring character case.

   string-suffix-length

 -- Scheme Procedure: string-suffix-length s1 s2 [start1 [end1 [start2
          [end2]]]]
     Return the length of the longest common suffix of the two strings.

   string-suffix-length-ci

 -- Scheme Procedure: string-suffix-length-ci s1 s2 [start1 [end1
          [start2 [end2]]]]
     Return the length of the longest common suffix of the two strings,
     ignoring character case.

   string-prefix?

 -- Scheme Procedure: string-prefix? s1 s2 [start1 [end1 [start2
          [end2]]]]
     Is S1 a prefix of S2?

   string-prefix-ci?

 -- Scheme Procedure: string-prefix-ci? s1 s2 [start1 [end1 [start2
          [end2]]]]
     Is S1 a prefix of S2, ignoring character case?

   string-suffix?

 -- Scheme Procedure: string-suffix? s1 s2 [start1 [end1 [start2
          [end2]]]]
     Is S1 a suffix of S2?

   string-suffix-ci?

 -- Scheme Procedure: string-suffix-ci? s1 s2 [start1 [end1 [start2
          [end2]]]]
     Is S1 a suffix of S2, ignoring character case?

   string-index

 -- Scheme Procedure: string-index s char_pred [start [end]]
     Search through the string S from left to right, returning the
     index of the first occurence of a character which

        * equals CHAR_PRED, if it is character,

        * satisifies the predicate CHAR_PRED, if it is a procedure,

        * is in the set CHAR_PRED, if it is a character set.

   string-index-right

 -- Scheme Procedure: string-index-right s char_pred [start [end]]
     Search through the string S from right to left, returning the
     index of the last occurence of a character which

        * equals CHAR_PRED, if it is character,

        * satisifies the predicate CHAR_PRED, if it is a procedure,

        * is in the set if CHAR_PRED is a character set.

   string-rindex

 -- Scheme Procedure: string-rindex s char_pred [start [end]]
     Search through the string S from right to left, returning the
     index of the last occurence of a character which

        * equals CHAR_PRED, if it is character,

        * satisifies the predicate CHAR_PRED, if it is a procedure,

        * is in the set if CHAR_PRED is a character set.

   string-skip

 -- Scheme Procedure: string-skip s char_pred [start [end]]
     Search through the string S from left to right, returning the
     index of the first occurence of a character which

        * does not equal CHAR_PRED, if it is character,

        * does not satisify the predicate CHAR_PRED, if it is a
          procedure,

        * is not in the set if CHAR_PRED is a character set.

   string-skip-right

 -- Scheme Procedure: string-skip-right s char_pred [start [end]]
     Search through the string S from right to left, returning the
     index of the last occurence of a character which

        * does not equal CHAR_PRED, if it is character,

        * does not satisfy the predicate CHAR_PRED, if it is a
          procedure,

        * is not in the set if CHAR_PRED is a character set.

   string-count

 -- Scheme Procedure: string-count s char_pred [start [end]]
     Return the count of the number of characters in the string S which

        * equals CHAR_PRED, if it is character,

        * satisifies the predicate CHAR_PRED, if it is a procedure.

        * is in the set CHAR_PRED, if it is a character set.

   string-contains

 -- Scheme Procedure: string-contains s1 s2 [start1 [end1 [start2
          [end2]]]]
     Does string S1 contain string S2?  Return the index in S1 where S2
     occurs as a substring, or false.  The optional start/end indices
     restrict the operation to the indicated substrings.

   string-contains-ci

 -- Scheme Procedure: string-contains-ci s1 s2 [start1 [end1 [start2
          [end2]]]]
     Does string S1 contain string S2?  Return the index in S1 where S2
     occurs as a substring, or false.  The optional start/end indices
     restrict the operation to the indicated substrings.  Character
     comparison is done case-insensitively.

   string-upcase!

 -- Scheme Procedure: string-upcase! str [start [end]]
     Destructively upcase every character in `str'.

          (string-upcase! y)
          => "ARRDEFG"
          y
          => "ARRDEFG"

   string-upcase

 -- Scheme Procedure: string-upcase str [start [end]]
     Upcase every character in `str'.

   string-downcase!

 -- Scheme Procedure: string-downcase! str [start [end]]
     Destructively downcase every character in STR.

          y
          => "ARRDEFG"
          (string-downcase! y)
          => "arrdefg"
          y
          => "arrdefg"

   string-downcase

 -- Scheme Procedure: string-downcase str [start [end]]
     Downcase every character in STR.

   string-titlecase!

 -- Scheme Procedure: string-titlecase! str [start [end]]
     Destructively titlecase every first character in a word in STR.

   string-titlecase

 -- Scheme Procedure: string-titlecase str [start [end]]
     Titlecase every first character in a word in STR.

   string-capitalize!

 -- Scheme Procedure: string-capitalize! str
     Upcase the first character of every word in STR destructively and
     return STR.

          y                      => "hello world"
          (string-capitalize! y) => "Hello World"
          y                      => "Hello World"

   string-capitalize

 -- Scheme Procedure: string-capitalize str
     Return a freshly allocated string with the characters in STR,
     where the first character of every word is capitalized.

   string-reverse

 -- Scheme Procedure: string-reverse str [start [end]]
     Reverse the string STR.  The optional arguments START and END
     delimit the region of STR to operate on.

   string-reverse!

 -- Scheme Procedure: string-reverse! str [start [end]]
     Reverse the string STR in-place.  The optional arguments START and
     END delimit the region of STR to operate on.  The return value is
     unspecified.

   string-append/shared

 -- Scheme Procedure: string-append/shared . rest
     Like `string-append', but the result may share memory with the
     argument strings.

   string-concatenate

 -- Scheme Procedure: string-concatenate ls
     Append the elements of LS (which must be strings) together into a
     single string.  Guaranteed to return a freshly allocated string.

   string-concatenate-reverse

 -- Scheme Procedure: string-concatenate-reverse ls [final_string [end]]
     Without optional arguments, this procedure is equivalent to

          (string-concatenate (reverse ls))

     If the optional argument FINAL_STRING is specified, it is consed
     onto the beginning to LS before performing the list-reverse and
     string-concatenate operations.  If END is given, only the
     characters of FINAL_STRING up to index END are used.

     Guaranteed to return a freshly allocated string.

   string-concatenate/shared

 -- Scheme Procedure: string-concatenate/shared ls
     Like `string-concatenate', but the result may share memory with
     the strings in the list LS.

   string-concatenate-reverse/shared

 -- Scheme Procedure: string-concatenate-reverse/shared ls
          [final_string [end]]
     Like `string-concatenate-reverse', but the result may share memory
     with the the strings in the LS arguments.

   string-map

 -- Scheme Procedure: string-map proc s [start [end]]
     PROC is a char->char procedure, it is mapped over S.  The order in
     which the procedure is applied to the string elements is not
     specified.

   string-map!

 -- Scheme Procedure: string-map! proc s [start [end]]
     PROC is a char->char procedure, it is mapped over S.  The order in
     which the procedure is applied to the string elements is not
     specified.  The string S is modified in-place, the return value is
     not specified.

   string-fold

 -- Scheme Procedure: string-fold kons knil s [start [end]]
     Fold KONS over the characters of S, with KNIL as the terminating
     element, from left to right.  KONS must expect two arguments: The
     actual character and the last result of KONS' application.

   string-fold-right

 -- Scheme Procedure: string-fold-right kons knil s [start [end]]
     Fold KONS over the characters of S, with KNIL as the terminating
     element, from right to left.  KONS must expect two arguments: The
     actual character and the last result of KONS' application.

   string-unfold

 -- Scheme Procedure: string-unfold p f g seed [base [make_final]]
        * G is used to generate a series of _seed_ values from the
          initial SEED: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of these seed values.

        * F maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in
          a left-to-right order.

        * BASE is the optional initial/leftmost portion of the
          constructed string; it default to the empty string.

        * MAKE_FINAL is applied to the terminal seed value (on which P
          returns true) to produce the final/rightmost portion of the
          constructed string.  It defaults to `(lambda (x) )'.

   string-unfold-right

 -- Scheme Procedure: string-unfold-right p f g seed [base [make_final]]
        * G is used to generate a series of _seed_ values from the
          initial SEED: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of these seed values.

        * F maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in
          a right-to-left order.

        * BASE is the optional initial/rightmost portion of the
          constructed string; it default to the empty string.

        * MAKE_FINAL is applied to the terminal seed value (on which P
          returns true) to produce the final/leftmost portion of the
          constructed string.  It defaults to `(lambda (x) )'.

   string-for-each

 -- Scheme Procedure: string-for-each proc s [start [end]]
     PROC is mapped over S in left-to-right order.  The return value is
     not specified.

   string-for-each-index

 -- Scheme Procedure: string-for-each-index proc s [start [end]]
     Call `(PROC i)' for each index i in S, from left to right.

     For example, to change characters to alternately upper and lower
     case,

          (define str (string-copy "studly"))
          (string-for-each-index
              (lambda (i)
                (string-set! str i
                  ((if (even? i) char-upcase char-downcase)
                   (string-ref str i))))
              str)
          str => "StUdLy"

   xsubstring

 -- Scheme Procedure: xsubstring s from [to [start [end]]]
     This is the _extended substring_ procedure that implements
     replicated copying of a substring of some string.

     S is a string, START and END are optional arguments that demarcate
     a substring of S, defaulting to 0 and the length of S.  Replicate
     this substring up and down index space, in both the positive and
     negative directions.  `xsubstring' returns the substring of this
     string beginning at index FROM, and ending at TO, which defaults
     to FROM + (END - START).

   string-xcopy!

 -- Scheme Procedure: string-xcopy! target tstart s sfrom [sto [start
          [end]]]
     Exactly the same as `xsubstring', but the extracted text is
     written into the string TARGET starting at index TSTART.  The
     operation is not defined if `(eq?  TARGET S)' or these arguments
     share storage - you cannot copy a string on top of itself.

   string-replace

 -- Scheme Procedure: string-replace s1 s2 [start1 [end1 [start2
          [end2]]]]
     Return the string S1, but with the characters START1 ... END1
     replaced by the characters START2 ... END2 from S2.

   string-tokenize

 -- Scheme Procedure: string-tokenize s [token_set [start [end]]]
     Split the string S into a list of substrings, where each substring
     is a maximal non-empty contiguous sequence of characters from the
     character set TOKEN_SET, which defaults to `char-set:graphic'.  If
     START or END indices are provided, they restrict `string-tokenize'
     to operating on the indicated substring of S.

   string-split

 -- Scheme Procedure: string-split str chr
     Split the string STR into the a list of the substrings delimited
     by appearances of the character CHR.  Note that an empty substring
     between separator characters will result in an empty string in the
     result list.

          (string-split "root:x:0:0:root:/root:/bin/bash" #\:)
          =>
          ("root" "x" "0" "0" "root" "/root" "/bin/bash")

          (string-split "::" #\:)
          =>
          ("" "" "")

          (string-split "" #\:)
          =>
          ("")

   string-filter

 -- Scheme Procedure: string-filter s char_pred [start [end]]
     Filter the string S, retaining only those characters which satisfy
     CHAR_PRED.

     If CHAR_PRED is a procedure, it is applied to each character as a
     predicate, if it is a character, it is tested for equality and if
     it is a character set, it is tested for membership.

   string-delete

 -- Scheme Procedure: string-delete s char_pred [start [end]]
     Delete characters satisfying CHAR_PRED from S.

     If CHAR_PRED is a procedure, it is applied to each character as a
     predicate, if it is a character, it is tested for equality and if
     it is a character set, it is tested for membership.

   char-set?

 -- Scheme Procedure: char-set? obj
     Return `#t' if OBJ is a character set, `#f' otherwise.

   char-set=

 -- Scheme Procedure: char-set= . char_sets
     Return `#t' if all given character sets are equal.

   char-set<=

 -- Scheme Procedure: char-set<= . char_sets
     Return `#t' if every character set CSi is a subset of character
     set CSi+1.

   char-set-hash

 -- Scheme Procedure: char-set-hash cs [bound]
     Compute a hash value for the character set CS.  If BOUND is given
     and non-zero, it restricts the returned value to the range 0 ...
     BOUND - 1.

   char-set-cursor

 -- Scheme Procedure: char-set-cursor cs
     Return a cursor into the character set CS.

   char-set-ref

 -- Scheme Procedure: char-set-ref cs cursor
     Return the character at the current cursor position CURSOR in the
     character set CS.  It is an error to pass a cursor for which
     `end-of-char-set?' returns true.

   char-set-cursor-next

 -- Scheme Procedure: char-set-cursor-next cs cursor
     Advance the character set cursor CURSOR to the next character in
     the character set CS.  It is an error if the cursor given
     satisfies `end-of-char-set?'.

   end-of-char-set?

 -- Scheme Procedure: end-of-char-set? cursor
     Return `#t' if CURSOR has reached the end of a character set, `#f'
     otherwise.

   char-set-fold

 -- Scheme Procedure: char-set-fold kons knil cs
     Fold the procedure KONS over the character set CS, initializing it
     with KNIL.

   char-set-unfold

 -- Scheme Procedure: char-set-unfold p f g seed [base_cs]
     This is a fundamental constructor for character sets.
        * G is used to generate a series of "seed" values from the
          initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of the seed values.

        * F maps each seed value to a character. These characters are
          added to the base character set BASE_CS to form the result;
          BASE_CS defaults to the empty set.

   char-set-unfold!

 -- Scheme Procedure: char-set-unfold! p f g seed base_cs
     This is a fundamental constructor for character sets.
        * G is used to generate a series of "seed" values from the
          initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of the seed values.

        * F maps each seed value to a character. These characters are
          added to the base character set BASE_CS to form the result;
          BASE_CS defaults to the empty set.

   char-set-for-each

 -- Scheme Procedure: char-set-for-each proc cs
     Apply PROC to every character in the character set CS.  The return
     value is not specified.

   char-set-map

 -- Scheme Procedure: char-set-map proc cs
     Map the procedure PROC over every character in CS.  PROC must be a
     character -> character procedure.

   char-set-copy

 -- Scheme Procedure: char-set-copy cs
     Return a newly allocated character set containing all characters
     in CS.

   char-set

 -- Scheme Procedure: char-set . rest
     Return a character set containing all given characters.

   list->char-set

 -- Scheme Procedure: list->char-set list [base_cs]
     Convert the character list LIST to a character set.  If the
     character set BASE_CS is given, the character in this set are also
     included in the result.

   list->char-set!

 -- Scheme Procedure: list->char-set! list base_cs
     Convert the character list LIST to a character set.  The
     characters are added to BASE_CS and BASE_CS is returned.

   string->char-set

 -- Scheme Procedure: string->char-set str [base_cs]
     Convert the string STR to a character set.  If the character set
     BASE_CS is given, the characters in this set are also included in
     the result.

   string->char-set!

 -- Scheme Procedure: string->char-set! str base_cs
     Convert the string STR to a character set.  The characters from
     the string are added to BASE_CS, and BASE_CS is returned.

   char-set-filter

 -- Scheme Procedure: char-set-filter pred cs [base_cs]
     Return a character set containing every character from CS so that
     it satisfies PRED.  If provided, the characters from BASE_CS are
     added to the result.

   char-set-filter!

 -- Scheme Procedure: char-set-filter! pred cs base_cs
     Return a character set containing every character from CS so that
     it satisfies PRED.  The characters are added to BASE_CS and
     BASE_CS is returned.

   ucs-range->char-set

 -- Scheme Procedure: ucs-range->char-set lower upper [error [base_cs]]
     Return a character set containing all characters whose character
     codes lie in the half-open range [LOWER,UPPER).

     If ERROR is a true value, an error is signalled if the specified
     range contains characters which are not contained in the
     implemented character range.  If ERROR is `#f', these characters
     are silently left out of the resultung character set.

     The characters in BASE_CS are added to the result, if given.

   ucs-range->char-set!

 -- Scheme Procedure: ucs-range->char-set! lower upper error base_cs
     Return a character set containing all characters whose character
     codes lie in the half-open range [LOWER,UPPER).

     If ERROR is a true value, an error is signalled if the specified
     range contains characters which are not contained in the
     implemented character range.  If ERROR is `#f', these characters
     are silently left out of the resultung character set.

     The characters are added to BASE_CS and BASE_CS is returned.

   ->char-set

 -- Scheme Procedure: ->char-set x
     Coerces x into a char-set. X may be a string, character or
     char-set. A string is converted to the set of its constituent
     characters; a character is converted to a singleton set; a
     char-set is returned as-is.

   char-set-size

 -- Scheme Procedure: char-set-size cs
     Return the number of elements in character set CS.

   char-set-count

 -- Scheme Procedure: char-set-count pred cs
     Return the number of the elements int the character set CS which
     satisfy the predicate PRED.

   char-set->list

 -- Scheme Procedure: char-set->list cs
     Return a list containing the elements of the character set CS.

   char-set->string

 -- Scheme Procedure: char-set->string cs
     Return a string containing the elements of the character set CS.
     The order in which the characters are placed in the string is not
     defined.

   char-set-contains?

 -- Scheme Procedure: char-set-contains? cs ch
     Return `#t' iff the character CH is contained in the character set
     CS.

   char-set-every

 -- Scheme Procedure: char-set-every pred cs
     Return a true value if every character in the character set CS
     satisfies the predicate PRED.

   char-set-any

 -- Scheme Procedure: char-set-any pred cs
     Return a true value if any character in the character set CS
     satisfies the predicate PRED.

   char-set-adjoin

 -- Scheme Procedure: char-set-adjoin cs . rest
     Add all character arguments to the first argument, which must be a
     character set.

   char-set-delete

 -- Scheme Procedure: char-set-delete cs . rest
     Delete all character arguments from the first argument, which must
     be a character set.

   char-set-adjoin!

 -- Scheme Procedure: char-set-adjoin! cs . rest
     Add all character arguments to the first argument, which must be a
     character set.

   char-set-delete!

 -- Scheme Procedure: char-set-delete! cs . rest
     Delete all character arguments from the first argument, which must
     be a character set.

   char-set-complement

 -- Scheme Procedure: char-set-complement cs
     Return the complement of the character set CS.

   char-set-union

 -- Scheme Procedure: char-set-union . rest
     Return the union of all argument character sets.

   char-set-intersection

 -- Scheme Procedure: char-set-intersection . rest
     Return the intersection of all argument character sets.

   char-set-difference

 -- Scheme Procedure: char-set-difference cs1 . rest
     Return the difference of all argument character sets.

   char-set-xor

 -- Scheme Procedure: char-set-xor . rest
     Return the exclusive-or of all argument character sets.

   char-set-diff+intersection

 -- Scheme Procedure: char-set-diff+intersection cs1 . rest
     Return the difference and the intersection of all argument
     character sets.

   char-set-complement!

 -- Scheme Procedure: char-set-complement! cs
     Return the complement of the character set CS.

   char-set-union!

 -- Scheme Procedure: char-set-union! cs1 . rest
     Return the union of all argument character sets.

   char-set-intersection!

 -- Scheme Procedure: char-set-intersection! cs1 . rest
     Return the intersection of all argument character sets.

   char-set-difference!

 -- Scheme Procedure: char-set-difference! cs1 . rest
     Return the difference of all argument character sets.

   char-set-xor!

 -- Scheme Procedure: char-set-xor! cs1 . rest
     Return the exclusive-or of all argument character sets.

   char-set-diff+intersection!

 -- Scheme Procedure: char-set-diff+intersection! cs1 cs2 . rest
     Return the difference and the intersection of all argument
     character sets.

   string=?

 -- Scheme Procedure: string=? s1 s2
     Lexicographic equality predicate; return `#t' if the two strings
     are the same length and contain the same characters in the same
     positions, otherwise return `#f'.

     The procedure `string-ci=?' treats upper and lower case letters as
     though they were the same character, but `string=?' treats upper
     and lower case as distinct characters.

   string-ci=?

 -- Scheme Procedure: string-ci=? s1 s2
     Case-insensitive string equality predicate; return `#t' if the two
     strings are the same length and their component characters match
     (ignoring case) at each position; otherwise return `#f'.

   string<?

 -- Scheme Procedure: string<? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than S2.

   string<=?

 -- Scheme Procedure: string<=? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than or equal to S2.

   string>?

 -- Scheme Procedure: string>? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than S2.

   string>=?

 -- Scheme Procedure: string>=? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than or equal to S2.

   string-ci<?

 -- Scheme Procedure: string-ci<? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than S2 regardless of case.

   string-ci<=?

 -- Scheme Procedure: string-ci<=? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than or equal to S2 regardless of
     case.

   string-ci>?

 -- Scheme Procedure: string-ci>? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than S2 regardless of case.

   string-ci>=?

 -- Scheme Procedure: string-ci>=? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than or equal to S2 regardless of
     case.

   object->string

 -- Scheme Procedure: object->string obj [printer]
     Return a Scheme string obtained by printing OBJ.  Printing
     function can be specified by the optional second argument PRINTER
     (default: `write').

   call-with-output-string

 -- Scheme Procedure: call-with-output-string proc
     Calls the one-argument procedure PROC with a newly created output
     port.  When the function returns, the string composed of the
     characters written into the port is returned.

   call-with-input-string

 -- Scheme Procedure: call-with-input-string string proc
     Calls the one-argument procedure PROC with a newly created input
     port from which STRING's contents may be read.  The value yielded
     by the PROC is returned.

   open-input-string

 -- Scheme Procedure: open-input-string str
     Take a string and return an input port that delivers characters
     from the string. The port can be closed by `close-input-port',
     though its storage will be reclaimed by the garbage collector if
     it becomes inaccessible.

   open-output-string

 -- Scheme Procedure: open-output-string
     Return an output port that will accumulate characters for
     retrieval by `get-output-string'. The port can be closed by the
     procedure `close-output-port', though its storage will be
     reclaimed by the garbage collector if it becomes inaccessible.

   get-output-string

 -- Scheme Procedure: get-output-string port
     Given an output port created by `open-output-string', return a
     string consisting of the characters that have been output to the
     port so far.

   eval-string

 -- Scheme Procedure: eval-string string [module]
     Evaluate STRING as the text representation of a Scheme form or
     forms, and return whatever value they produce.  Evaluation takes
     place in the given module, or the current module when no module is
     given.  While the code is evaluated, the given module is made the
     current one.  The current module is restored when this procedure
     returns.

   make-struct-layout

 -- Scheme Procedure: make-struct-layout fields
     Return a new structure layout object.

     FIELDS must be a string made up of pairs of characters strung
     together.  The first character of each pair describes a field
     type, the second a field protection.  Allowed types are 'p' for
     GC-protected Scheme data, 'u' for unprotected binary data, and 's'
     for a field that points to the structure itself.    Allowed
     protections are 'w' for mutable fields, 'r' for read-only fields,
     and 'o' for opaque fields.  The last field protection
     specification may be capitalized to indicate that the field is a
     tail-array.

   struct?

 -- Scheme Procedure: struct? x
     Return `#t' iff X is a structure object, else `#f'.

   struct-vtable?

 -- Scheme Procedure: struct-vtable? x
     Return `#t' iff X is a vtable structure.

   make-struct

 -- Scheme Procedure: make-struct vtable tail_array_size . init
     Create a new structure.

     TYPE must be a vtable structure (*note Vtables::).

     TAIL-ELTS must be a non-negative integer.  If the layout
     specification indicated by TYPE includes a tail-array, this is the
     number of elements allocated to that array.

     The INIT1, ... are optional arguments describing how successive
     fields of the structure should be initialized.  Only fields with
     protection 'r' or 'w' can be initialized, except for fields of
     type 's', which are automatically initialized to point to the new
     structure itself; fields with protection 'o' can not be
     initialized by Scheme programs.

     If fewer optional arguments than initializable fields are supplied,
     fields of type 'p' get default value #f while fields of type 'u'
     are initialized to 0.

     Structs are currently the basic representation for record-like data
     structures in Guile.  The plan is to eventually replace them with a
     new representation which will at the same time be easier to use and
     more powerful.

     For more information, see the documentation for
     `make-vtable-vtable'.

   make-vtable-vtable

 -- Scheme Procedure: make-vtable-vtable user_fields tail_array_size .
          init
     Return a new, self-describing vtable structure.

     USER-FIELDS is a string describing user defined fields of the
     vtable beginning at index `vtable-offset-user' (see
     `make-struct-layout').

     TAIL-SIZE specifies the size of the tail-array (if any) of this
     vtable.

     INIT1, ... are the optional initializers for the fields of the
     vtable.

     Vtables have one initializable system field--the struct printer.
     This field comes before the user fields in the initializers passed
     to `make-vtable-vtable' and `make-struct', and thus works as a
     third optional argument to `make-vtable-vtable' and a fourth to
     `make-struct' when creating vtables:

     If the value is a procedure, it will be called instead of the
     standard printer whenever a struct described by this vtable is
     printed.  The procedure will be called with arguments STRUCT and
     PORT.

     The structure of a struct is described by a vtable, so the vtable
     is in essence the type of the struct.  The vtable is itself a
     struct with a vtable.  This could go on forever if it weren't for
     the vtable-vtables which are self-describing vtables, and thus
     terminate the chain.

     There are several potential ways of using structs, but the standard
     one is to use three kinds of structs, together building up a type
     sub-system: one vtable-vtable working as the root and one or
     several "types", each with a set of "instances".  (The
     vtable-vtable should be compared to the class <class> which is the
     class of itself.)

          (define ball-root (make-vtable-vtable "pr" 0))

          (define (make-ball-type ball-color)
            (make-struct ball-root 0
          	       (make-struct-layout "pw")
                         (lambda (ball port)
                           (format port "#<a ~A ball owned by ~A>"
                                   (color ball)
                                   (owner ball)))
                         ball-color))
          (define (color ball) (struct-ref (struct-vtable ball) vtable-offset-user))
          (define (owner ball) (struct-ref ball 0))

          (define red (make-ball-type 'red))
          (define green (make-ball-type 'green))

          (define (make-ball type owner) (make-struct type 0 owner))

          (define ball (make-ball green 'Nisse))
          ball => #<a green ball owned by Nisse>

   make-vtable

 -- Scheme Procedure: make-vtable fields [printer]
     Create a vtable, for creating structures with the given FIELDS.

     The optional PRINTER argument is a function to be called `(PRINTER
     struct port)' on the structures created.  It should look at STRUCT
     and write to PORT.

   struct-ref

 -- Scheme Procedure: struct-ref handle pos
 -- Scheme Procedure: struct-set! struct n value
     Access (or modify) the Nth field of STRUCT.

     If the field is of type 'p', then it can be set to an arbitrary
     value.

     If the field is of type 'u', then it can only be set to a
     non-negative integer value small enough to fit in one machine word.

   struct-set!

 -- Scheme Procedure: struct-set! handle pos val
     Set the slot of the structure HANDLE with index POS to VAL.
     Signal an error if the slot can not be written to.

   struct-vtable

 -- Scheme Procedure: struct-vtable handle
     Return the vtable structure that describes the type of STRUCT.

   struct-vtable-tag

 -- Scheme Procedure: struct-vtable-tag handle
     Return the vtable tag of the structure HANDLE.

   struct-vtable-name

 -- Scheme Procedure: struct-vtable-name vtable
     Return the name of the vtable VTABLE.

   set-struct-vtable-name!

 -- Scheme Procedure: set-struct-vtable-name! vtable name
     Set the name of the vtable VTABLE to NAME.

   symbol?

 -- Scheme Procedure: symbol? obj
     Return `#t' if OBJ is a symbol, otherwise return `#f'.

   symbol-interned?

 -- Scheme Procedure: symbol-interned? symbol
     Return `#t' if SYMBOL is interned, otherwise return `#f'.

   make-symbol

 -- Scheme Procedure: make-symbol name
     Return a new uninterned symbol with the name NAME.  The returned
     symbol is guaranteed to be unique and future calls to
     `string->symbol' will not return it.

   symbol->string

 -- Scheme Procedure: symbol->string s
     Return the name of SYMBOL as a string.  If the symbol was part of
     an object returned as the value of a literal expression (section
     *note Literal expressions: (r5rs)Literal expressions.) or by a
     call to the `read' procedure, and its name contains alphabetic
     characters, then the string returned will contain characters in
     the implementation's preferred standard case--some implementations
     will prefer upper case, others lower case.  If the symbol was
     returned by `string->symbol', the case of characters in the string
     returned will be the same as the case in the string that was
     passed to `string->symbol'.  It is an error to apply mutation
     procedures like `string-set!' to strings returned by this
     procedure.

     The following examples assume that the implementation's standard
     case is lower case:

          (symbol->string 'flying-fish)    => "flying-fish"
          (symbol->string 'Martin)         =>  "martin"
          (symbol->string
             (string->symbol "Malvina")) => "Malvina"

   string->symbol

 -- Scheme Procedure: string->symbol string
     Return the symbol whose name is STRING. This procedure can create
     symbols with names containing special characters or letters in the
     non-standard case, but it is usually a bad idea to create such
     symbols because in some implementations of Scheme they cannot be
     read as themselves.  See `symbol->string'.

     The following examples assume that the implementation's standard
     case is lower case:

          (eq? 'mISSISSIppi 'mississippi) => #t
          (string->symbol "mISSISSIppi") => the symbol with name "mISSISSIppi"
          (eq? 'bitBlt (string->symbol "bitBlt")) => #f
          (eq? 'JollyWog
            (string->symbol (symbol->string 'JollyWog))) => #t
          (string=? "K. Harper, M.D."
            (symbol->string
              (string->symbol "K. Harper, M.D."))) =>#t

   string-ci->symbol

 -- Scheme Procedure: string-ci->symbol str
     Return the symbol whose name is STR.  STR is converted to
     lowercase before the conversion is done, if Guile is currently
     reading symbols case-insensitively.

   gensym

 -- Scheme Procedure: gensym [prefix]
     Create a new symbol with a name constructed from a prefix and a
     counter value. The string PREFIX can be specified as an optional
     argument. Default prefix is ` g'.  The counter is increased by 1
     at each call. There is no provision for resetting the counter.

   symbol-hash

 -- Scheme Procedure: symbol-hash symbol
     Return a hash value for SYMBOL.

   symbol-fref

 -- Scheme Procedure: symbol-fref s
     Return the contents of SYMBOL's "function slot".

   symbol-pref

 -- Scheme Procedure: symbol-pref s
     Return the "property list" currently associated with SYMBOL.

   symbol-fset!

 -- Scheme Procedure: symbol-fset! s val
     Change the binding of SYMBOL's function slot.

   symbol-pset!

 -- Scheme Procedure: symbol-pset! s val
     Change the binding of SYMBOL's property slot.

   call-with-new-thread

 -- Scheme Procedure: call-with-new-thread thunk [handler]
     Call `thunk' in a new thread and with a new dynamic state,
     returning a new thread object representing the thread.  The
     procedure THUNK is called via `with-continuation-barrier'.

     When HANDLER is specified, then THUNK is called from within a
     `catch' with tag `#t' that has HANDLER as its handler.  This catch
     is established inside the continuation barrier.

     Once THUNK or HANDLER returns, the return value is made the _exit
     value_ of the thread and the thread is terminated.

   yield

 -- Scheme Procedure: yield
     Move the calling thread to the end of the scheduling queue.

   join-thread

 -- Scheme Procedure: join-thread thread
     Suspend execution of the calling thread until the target THREAD
     terminates, unless the target THREAD has already terminated.

   make-mutex

 -- Scheme Procedure: make-mutex
     Create a new mutex.

   make-recursive-mutex

 -- Scheme Procedure: make-recursive-mutex
     Create a new recursive mutex.

   lock-mutex

 -- Scheme Procedure: lock-mutex mx
     Lock MUTEX. If the mutex is already locked, the calling thread
     blocks until the mutex becomes available. The function returns
     when the calling thread owns the lock on MUTEX.  Locking a mutex
     that a thread already owns will succeed right away and will not
     block the thread.  That is, Guile's mutexes are _recursive_.

   try-mutex

 -- Scheme Procedure: try-mutex mutex
     Try to lock MUTEX. If the mutex is already locked by someone else,
     return `#f'.  Else lock the mutex and return `#t'.

   unlock-mutex

 -- Scheme Procedure: unlock-mutex mx
     Unlocks MUTEX if the calling thread owns the lock on MUTEX.
     Calling unlock-mutex on a mutex not owned by the current thread
     results in undefined behaviour. Once a mutex has been unlocked,
     one thread blocked on MUTEX is awakened and grabs the mutex lock.
     Every call to `lock-mutex' by this thread must be matched with a
     call to `unlock-mutex'.  Only the last call to `unlock-mutex' will
     actually unlock the mutex.

   make-condition-variable

 -- Scheme Procedure: make-condition-variable
     Make a new condition variable.

   wait-condition-variable

 -- Scheme Procedure: wait-condition-variable cv mx [t]
     Wait until COND-VAR has been signalled.  While waiting, MUTEX is
     atomically unlocked (as with `unlock-mutex') and is locked again
     when this function returns.  When TIME is given, it specifies a
     point in time where the waiting should be aborted.  It can be
     either a integer as returned by `current-time' or a pair as
     returned by `gettimeofday'.  When the waiting is aborted the mutex
     is locked and `#f' is returned.  When the condition variable is in
     fact signalled, the mutex is also locked and `#t' is returned.

   signal-condition-variable

 -- Scheme Procedure: signal-condition-variable cv
     Wake up one thread that is waiting for CV

   broadcast-condition-variable

 -- Scheme Procedure: broadcast-condition-variable cv
     Wake up all threads that are waiting for CV.

   current-thread

 -- Scheme Procedure: current-thread
     Return the thread that called this function.

   all-threads

 -- Scheme Procedure: all-threads
     Return a list of all threads.

   thread-exited?

 -- Scheme Procedure: thread-exited? thread
     Return `#t' iff THREAD has exited.


   catch

 -- Scheme Procedure: catch key thunk handler [pre_unwind_handler]
     Invoke THUNK in the dynamic context of HANDLER for exceptions
     matching KEY.  If thunk throws to the symbol KEY, then HANDLER is
     invoked this way:
          (handler key args ...)

     KEY is a symbol or `#t'.

     THUNK takes no arguments.  If THUNK returns normally, that is the
     return value of `catch'.

     Handler is invoked outside the scope of its own `catch'.  If
     HANDLER again throws to the same key, a new handler from further
     up the call chain is invoked.

     If the key is `#t', then a throw to _any_ symbol will match this
     call to `catch'.

     If a PRE-UNWIND-HANDLER is given and THUNK throws an exception
     that matches KEY, Guile calls the PRE-UNWIND-HANDLER before
     unwinding the dynamic state and invoking the main HANDLER.
     PRE-UNWIND-HANDLER should be a procedure with the same signature
     as HANDLER, that is `(lambda (key . args))'.  It is typically used
     to save the stack at the point where the exception occurred, but
     can also query other parts of the dynamic state at that point,
     such as fluid values.

     A PRE-UNWIND-HANDLER can exit either normally or non-locally.  If
     it exits normally, Guile unwinds the stack and dynamic context and
     then calls the normal (third argument) handler.  If it exits
     non-locally, that exit determines the continuation.

   with-throw-handler

 -- Scheme Procedure: with-throw-handler key thunk handler
     Add HANDLER to the dynamic context as a throw handler for key KEY,
     then invoke THUNK.

   lazy-catch

 -- Scheme Procedure: lazy-catch key thunk handler
     This behaves exactly like `catch', except that it does not unwind
     the stack before invoking HANDLER.  If the HANDLER procedure
     returns normally, Guile rethrows the same exception again to the
     next innermost catch, lazy-catch or throw handler.  If the HANDLER
     exits non-locally, that exit determines the continuation.

   throw

 -- Scheme Procedure: throw key . args
     Invoke the catch form matching KEY, passing ARGS to the HANDLER.

     KEY is a symbol.  It will match catches of the same symbol or of
     `#t'.

     If there is no handler at all, Guile prints an error and then
     exits.

   values

 -- Scheme Procedure: values . args
     Delivers all of its arguments to its continuation.  Except for
     continuations created by the `call-with-values' procedure, all
     continuations take exactly one value.  The effect of passing no
     value or more than one value to continuations that were not
     created by `call-with-values' is unspecified.

   make-variable

 -- Scheme Procedure: make-variable init
     Return a variable initialized to value INIT.

   make-undefined-variable

 -- Scheme Procedure: make-undefined-variable
     Return a variable that is initially unbound.

   variable?

 -- Scheme Procedure: variable? obj
     Return `#t' iff OBJ is a variable object, else return `#f'.

   variable-ref

 -- Scheme Procedure: variable-ref var
     Dereference VAR and return its value.  VAR must be a variable
     object; see `make-variable' and `make-undefined-variable'.

   variable-set!

 -- Scheme Procedure: variable-set! var val
     Set the value of the variable VAR to VAL.  VAR must be a variable
     object, VAL can be any value. Return an unspecified value.

   variable-bound?

 -- Scheme Procedure: variable-bound? var
     Return `#t' iff VAR is bound to a value.  Throws an error if VAR
     is not a variable object.

   vector?

 -- Scheme Procedure: vector? obj
     Return `#t' if OBJ is a vector, otherwise return `#f'.

   list->vector

 -- Scheme Procedure: list->vector
     implemented by the C function "scm_vector"

   vector

 -- Scheme Procedure: vector . l
 -- Scheme Procedure: list->vector l
     Return a newly allocated vector composed of the given arguments.
     Analogous to `list'.

          (vector 'a 'b 'c) => #(a b c)

   make-vector

 -- Scheme Procedure: make-vector k [fill]
     Return a newly allocated vector of K elements.  If a second
     argument is given, then each position is initialized to FILL.
     Otherwise the initial contents of each position is unspecified.

   vector-copy

 -- Scheme Procedure: vector-copy vec
     Return a copy of VEC.

   vector->list

 -- Scheme Procedure: vector->list v
     Return a newly allocated list composed of the elements of V.

          (vector->list '#(dah dah didah)) =>  (dah dah didah)
          (list->vector '(dididit dah)) =>  #(dididit dah)

   vector-fill!

 -- Scheme Procedure: vector-fill! v fill
     Store FILL in every position of VECTOR.  The value returned by
     `vector-fill!' is unspecified.

   vector-move-left!

 -- Scheme Procedure: vector-move-left! vec1 start1 end1 vec2 start2
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-left!' copies elements in leftmost order.  Therefore,
     in the case where VEC1 and VEC2 refer to the same vector,
     `vector-move-left!' is usually appropriate when START1 is greater
     than START2.

   vector-move-right!

 -- Scheme Procedure: vector-move-right! vec1 start1 end1 vec2 start2
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-right!' copies elements in rightmost order.
     Therefore, in the case where VEC1 and VEC2 refer to the same
     vector, `vector-move-right!' is usually appropriate when START1 is
     less than START2.

   generalized-vector?

 -- Scheme Procedure: generalized-vector? obj
     Return `#t' if OBJ is a vector, string, bitvector, or uniform
     numeric vector.

   generalized-vector-length

 -- Scheme Procedure: generalized-vector-length v
     Return the length of the generalized vector V.

   generalized-vector-ref

 -- Scheme Procedure: generalized-vector-ref v idx
     Return the element at index IDX of the generalized vector V.

   generalized-vector-set!

 -- Scheme Procedure: generalized-vector-set! v idx val
     Set the element at index IDX of the generalized vector V to VAL.

   generalized-vector->list

 -- Scheme Procedure: generalized-vector->list v
     Return a new list whose elements are the elements of the
     generalized vector V.

   major-version

 -- Scheme Procedure: major-version
     Return a string containing Guile's major version number.  E.g.,
     the 1 in "1.6.5".

   minor-version

 -- Scheme Procedure: minor-version
     Return a string containing Guile's minor version number.  E.g.,
     the 6 in "1.6.5".

   micro-version

 -- Scheme Procedure: micro-version
     Return a string containing Guile's micro version number.  E.g.,
     the 5 in "1.6.5".

   version

 -- Scheme Procedure: version
 -- Scheme Procedure: major-version
 -- Scheme Procedure: minor-version
 -- Scheme Procedure: micro-version
     Return a string describing Guile's version number, or its major,
     minor or micro version number, respectively.

          (version) => "1.6.0"
          (major-version) => "1"
          (minor-version) => "6"
          (micro-version) => "0"

   effective-version

 -- Scheme Procedure: effective-version
     Return a string describing Guile's effective version number.
          (version) => "1.6.0"
          (effective-version) => "1.6"
          (major-version) => "1"
          (minor-version) => "6"
          (micro-version) => "0"

   make-soft-port

 -- Scheme Procedure: make-soft-port pv modes
     Return a port capable of receiving or delivering characters as
     specified by the MODES string (*note open-file: File Ports.).  PV
     must be a vector of length 5 or 6.  Its components are as follows:

       0. procedure accepting one character for output

       1. procedure accepting a string for output

       2. thunk for flushing output

       3. thunk for getting one character

       4. thunk for closing port (not by garbage collection)

       5. (if present and not `#f') thunk for computing the number of
          characters that can be read from the port without blocking.

     For an output-only port only elements 0, 1, 2, and 4 need be
     procedures.  For an input-only port only elements 3 and 4 need be
     procedures.  Thunks 2 and 4 can instead be `#f' if there is no
     useful operation for them to perform.

     If thunk 3 returns `#f' or an `eof-object' (*note eof-object?:
     (r5rs)Input.) it indicates that the port has reached end-of-file.
     For example:

          (define stdout (current-output-port))
          (define p (make-soft-port
                     (vector
                      (lambda (c) (write c stdout))
                      (lambda (s) (display s stdout))
                      (lambda () (display "." stdout))
                      (lambda () (char-upcase (read-char)))
                      (lambda () (display "@" stdout)))
                     "rw"))

          (write p p) => #<input-output: soft 8081e20>

   make-weak-vector

 -- Scheme Procedure: make-weak-vector size [fill]
     Return a weak vector with SIZE elements. If the optional argument
     FILL is given, all entries in the vector will be set to FILL. The
     default value for FILL is the empty list.

   list->weak-vector

 -- Scheme Procedure: list->weak-vector
     implemented by the C function "scm_weak_vector"

   weak-vector

 -- Scheme Procedure: weak-vector . l
 -- Scheme Procedure: list->weak-vector l
     Construct a weak vector from a list: `weak-vector' uses the list
     of its arguments while `list->weak-vector' uses its only argument
     L (a list) to construct a weak vector the same way `list->vector'
     would.

   weak-vector?

 -- Scheme Procedure: weak-vector? obj
     Return `#t' if OBJ is a weak vector. Note that all weak hashes are
     also weak vectors.

   make-weak-key-alist-vector

 -- Scheme Procedure: make-weak-key-alist-vector [size]
 -- Scheme Procedure: make-weak-value-alist-vector size
 -- Scheme Procedure: make-doubly-weak-alist-vector size
     Return a weak hash table with SIZE buckets. As with any hash
     table, choosing a good size for the table requires some caution.

     You can modify weak hash tables in exactly the same way you would
     modify regular hash tables. (*note Hash Tables::)

   make-weak-value-alist-vector

 -- Scheme Procedure: make-weak-value-alist-vector [size]
     Return a hash table with weak values with SIZE buckets.  (*note
     Hash Tables::)

   make-doubly-weak-alist-vector

 -- Scheme Procedure: make-doubly-weak-alist-vector size
     Return a hash table with weak keys and values with SIZE buckets.
     (*note Hash Tables::)

   weak-key-alist-vector?

 -- Scheme Procedure: weak-key-alist-vector? obj
 -- Scheme Procedure: weak-value-alist-vector? obj
 -- Scheme Procedure: doubly-weak-alist-vector? obj
     Return `#t' if OBJ is the specified weak hash table. Note that a
     doubly weak hash table is neither a weak key nor a weak value hash
     table.

   weak-value-alist-vector?

 -- Scheme Procedure: weak-value-alist-vector? obj
     Return `#t' if OBJ is a weak value hash table.

   doubly-weak-alist-vector?

 -- Scheme Procedure: doubly-weak-alist-vector? obj
     Return `#t' if OBJ is a doubly weak hash table.

   array-fill!

 -- Scheme Procedure: array-fill! ra fill
     Store FILL in every element of ARRAY.  The value returned is
     unspecified.

   array-copy-in-order!

 -- Scheme Procedure: array-copy-in-order!
     implemented by the C function "scm_array_copy_x"

   array-copy!

 -- Scheme Procedure: array-copy! src dst
 -- Scheme Procedure: array-copy-in-order! src dst
     Copy every element from vector or array SOURCE to the
     corresponding element of DESTINATION.  DESTINATION must have the
     same rank as SOURCE, and be at least as large in each dimension.
     The order is unspecified.

   array-map-in-order!

 -- Scheme Procedure: array-map-in-order!
     implemented by the C function "scm_array_map_x"

   array-map!

 -- Scheme Procedure: array-map! ra0 proc . lra
 -- Scheme Procedure: array-map-in-order! ra0 proc . lra
     ARRAY1, ... must have the same number of dimensions as ARRAY0 and
     have a range for each index which includes the range for the
     corresponding index in ARRAY0.  PROC is applied to each tuple of
     elements of ARRAY1 ... and the result is stored as the
     corresponding element in ARRAY0.  The value returned is
     unspecified.  The order of application is unspecified.

   array-for-each

 -- Scheme Procedure: array-for-each proc ra0 . lra
     Apply PROC to each tuple of elements of ARRAY0 ...  in row-major
     order.  The value returned is unspecified.

   array-index-map!

 -- Scheme Procedure: array-index-map! ra proc
     Apply PROC to the indices of each element of ARRAY in turn,
     storing the result in the corresponding element.  The value
     returned and the order of application are unspecified.

     One can implement ARRAY-INDEXES as
          (define (array-indexes array)
              (let ((ra (apply make-array #f (array-shape array))))
                (array-index-map! ra (lambda x x))
                ra))
     Another example:
          (define (apl:index-generator n)
              (let ((v (make-uniform-vector n 1)))
                (array-index-map! v (lambda (i) i))
                v))

   array?

 -- Scheme Procedure: array? obj [prot]
     Return `#t' if the OBJ is an array, and `#f' if not.

   typed-array?

 -- Scheme Procedure: typed-array? obj type
     Return `#t' if the OBJ is an array of type TYPE, and `#f' if not.

   array-rank

 -- Scheme Procedure: array-rank array
     Return the number of dimensions of the array ARRAY.


   array-dimensions

 -- Scheme Procedure: array-dimensions ra
     `array-dimensions' is similar to `array-shape' but replaces
     elements with a `0' minimum with one greater than the maximum. So:
          (array-dimensions (make-array 'foo '(-1 3) 5)) => ((-1 3) 5)

   shared-array-root

 -- Scheme Procedure: shared-array-root ra
     Return the root vector of a shared array.

   shared-array-offset

 -- Scheme Procedure: shared-array-offset ra
     Return the root vector index of the first element in the array.

   shared-array-increments

 -- Scheme Procedure: shared-array-increments ra
     For each dimension, return the distance between elements in the
     root vector.

   make-typed-array

 -- Scheme Procedure: make-typed-array type fill . bounds
     Create and return an array of type TYPE.

   make-array

 -- Scheme Procedure: make-array fill . bounds
     Create and return an array.

   dimensions->uniform-array

 -- Scheme Procedure: dimensions->uniform-array dims prot [fill]
 -- Scheme Procedure: make-uniform-vector length prototype [fill]
     Create and return a uniform array or vector of type corresponding
     to PROTOTYPE with dimensions DIMS or length LENGTH.  If FILL is
     supplied, it's used to fill the array, otherwise PROTOTYPE is used.

   make-shared-array

 -- Scheme Procedure: make-shared-array oldra mapfunc . dims
     `make-shared-array' can be used to create shared subarrays of other
     arrays.  The MAPPER is a function that translates coordinates in
     the new array into coordinates in the old array.  A MAPPER must be
     linear, and its range must stay within the bounds of the old
     array, but it can be otherwise arbitrary.  A simple example:
          (define fred (make-array #f 8 8))
          (define freds-diagonal
            (make-shared-array fred (lambda (i) (list i i)) 8))
          (array-set! freds-diagonal 'foo 3)
          (array-ref fred 3 3) => foo
          (define freds-center
            (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
          (array-ref freds-center 0 0) => foo

   transpose-array

 -- Scheme Procedure: transpose-array ra . args
     Return an array sharing contents with ARRAY, but with dimensions
     arranged in a different order.  There must be one DIM argument for
     each dimension of ARRAY.  DIM0, DIM1, ... should be integers
     between 0 and the rank of the array to be returned.  Each integer
     in that range must appear at least once in the argument list.

     The values of DIM0, DIM1, ... correspond to dimensions in the
     array to be returned, their positions in the argument list to
     dimensions of ARRAY.  Several DIMs may have the same value, in
     which case the returned array will have smaller rank than ARRAY.

          (transpose-array '#2((a b) (c d)) 1 0) => #2((a c) (b d))
          (transpose-array '#2((a b) (c d)) 0 0) => #1(a d)
          (transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) =>
                          #2((a 4) (b 5) (c 6))

   enclose-array

 -- Scheme Procedure: enclose-array ra . axes
     DIM0, DIM1 ... should be nonnegative integers less than the rank
     of ARRAY.  ENCLOSE-ARRAY returns an array resembling an array of
     shared arrays.  The dimensions of each shared array are the same
     as the DIMth dimensions of the original array, the dimensions of
     the outer array are the same as those of the original array that
     did not match a DIM.

     An enclosed array is not a general Scheme array.  Its elements may
     not be set using `array-set!'.  Two references to the same element
     of an enclosed array will be `equal?' but will not in general be
     `eq?'.  The value returned by ARRAY-PROTOTYPE when given an
     enclosed array is unspecified.

     examples:
          (enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1) =>
             #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>

          (enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0) =>
             #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>

   array-in-bounds?

 -- Scheme Procedure: array-in-bounds? v . args
     Return `#t' if its arguments would be acceptable to `array-ref'.

   array-ref

 -- Scheme Procedure: array-ref v . args
     Return the element at the `(index1, index2)' element in ARRAY.

   array-set!

 -- Scheme Procedure: array-set! v obj . args
     Set the element at the `(index1, index2)' element in ARRAY to
     NEW-VALUE.  The value returned by array-set! is unspecified.

   array-contents

 -- Scheme Procedure: array-contents ra [strict]
     If ARRAY may be "unrolled" into a one dimensional shared array
     without changing their order (last subscript changing fastest),
     then `array-contents' returns that shared array, otherwise it
     returns `#f'.  All arrays made by MAKE-ARRAY and
     MAKE-UNIFORM-ARRAY may be unrolled, some arrays made by
     MAKE-SHARED-ARRAY may not be.

     If the optional argument STRICT is provided, a shared array will
     be returned only if its elements are stored internally contiguous
     in memory.

   uniform-array-read!

 -- Scheme Procedure: uniform-array-read! ura [port_or_fd [start [end]]]
 -- Scheme Procedure: uniform-vector-read! uve [port-or-fdes] [start]
          [end]
     Attempt to read all elements of URA, in lexicographic order, as
     binary objects from PORT-OR-FDES.  If an end of file is
     encountered, the objects up to that point are put into URA
     (starting at the beginning) and the remainder of the array is
     unchanged.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be read, leaving the remainder of
     the vector unchanged.

     `uniform-array-read!' returns the number of objects read.
     PORT-OR-FDES may be omitted, in which case it defaults to the value
     returned by `(current-input-port)'.

   uniform-array-write

 -- Scheme Procedure: uniform-array-write ura [port_or_fd [start [end]]]
     Writes all elements of URA as binary objects to PORT-OR-FDES.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be written.

     The number of objects actually written is returned.  PORT-OR-FDES
     may be omitted, in which case it defaults to the value returned by
     `(current-output-port)'.

   bitvector?

 -- Scheme Procedure: bitvector? obj
     Return `#t' when OBJ is a bitvector, else return `#f'.

   make-bitvector

 -- Scheme Procedure: make-bitvector len [fill]
     Create a new bitvector of length LEN and optionally initialize all
     elements to FILL.

   bitvector

 -- Scheme Procedure: bitvector . bits
     Create a new bitvector with the arguments as elements.

   bitvector-length

 -- Scheme Procedure: bitvector-length vec
     Return the length of the bitvector VEC.

   bitvector-ref

 -- Scheme Procedure: bitvector-ref vec idx
     Return the element at index IDX of the bitvector VEC.

   bitvector-set!

 -- Scheme Procedure: bitvector-set! vec idx val
     Set the element at index IDX of the bitvector VEC when VAL is
     true, else clear it.

   bitvector-fill!

 -- Scheme Procedure: bitvector-fill! vec val
     Set all elements of the bitvector VEC when VAL is true, else clear
     them.

   list->bitvector

 -- Scheme Procedure: list->bitvector list
     Return a new bitvector initialized with the elements of LIST.

   bitvector->list

 -- Scheme Procedure: bitvector->list vec
     Return a new list initialized with the elements of the bitvector
     VEC.

   bit-count

 -- Scheme Procedure: bit-count b bitvector
     Return the number of occurrences of the boolean B in BITVECTOR.

   bit-position

 -- Scheme Procedure: bit-position item v k
     Return the index of the first occurrance of ITEM in bit vector V,
     starting from K.  If there is no ITEM entry between K and the end
     of BITVECTOR, then return `#f'.  For example,

          (bit-position #t #*000101 0)  => 3
          (bit-position #f #*0001111 3) => #f

   bit-set*!

 -- Scheme Procedure: bit-set*! v kv obj
     Set entries of bit vector V to OBJ, with KV selecting the entries
     to change.  The return value is unspecified.

     If KV is a bit vector, then those entries where it has `#t' are
     the ones in V which are set to OBJ.  KV and V must be the same
     length.  When OBJ is `#t' it's like KV is OR'ed into V.  Or when
     OBJ is `#f' it can be seen as an ANDNOT.

          (define bv #*01000010)
          (bit-set*! bv #*10010001 #t)
          bv
          => #*11010011

     If KV is a u32vector, then its elements are indices into V which
     are set to OBJ.

          (define bv #*01000010)
          (bit-set*! bv #u32(5 2 7) #t)
          bv
          => #*01100111

   bit-count*

 -- Scheme Procedure: bit-count* v kv obj
     Return a count of how many entries in bit vector V are equal to
     OBJ, with KV selecting the entries to consider.

     If KV is a bit vector, then those entries where it has `#t' are
     the ones in V which are considered.  KV and V must be the same
     length.

     If KV is a u32vector, then it contains the indexes in V to
     consider.

     For example,

          (bit-count* #*01110111 #*11001101 #t) => 3
          (bit-count* #*01110111 #u32(7 0 4) #f)  => 2

   bit-invert!

 -- Scheme Procedure: bit-invert! v
     Modify the bit vector V by replacing each element with its
     negation.

   array->list

 -- Scheme Procedure: array->list v
     Return a list consisting of all the elements, in order, of ARRAY.

   list->typed-array

 -- Scheme Procedure: list->typed-array type shape lst
     Return an array of the type TYPE with elements the same as those
     of LST.

     The argument SHAPE determines the number of dimensions of the
     array and their shape.  It is either an exact integer, giving the
     number of dimensions directly, or a list whose length specifies
     the number of dimensions and each element specified the lower and
     optionally the upper bound of the corresponding dimension.  When
     the element is list of two elements, these elements give the lower
     and upper bounds.  When it is an exact integer, it gives only the
     lower bound.

   list->array

 -- Scheme Procedure: list->array ndim lst
     Return an array with elements the same as those of LST.

   list->uniform-array

 -- Scheme Procedure: list->uniform-array ndim prot lst
     Return a uniform array of the type indicated by prototype PROT
     with elements the same as those of LST.  Elements must be of the
     appropriate type, no coercions are done.

     The argument NDIM determines the number of dimensions of the
     array.  It is either an exact integer, giving the number directly,
     or a list of exact integers, whose length specifies the number of
     dimensions and each element is the lower index bound of its
     dimension.

   array-type

 -- Scheme Procedure: array-type ra

   array-prototype

 -- Scheme Procedure: array-prototype ra
     Return an object that would produce an array of the same type as
     ARRAY, if used as the PROTOTYPE for `make-uniform-array'.

   dynamic-link

 -- Scheme Procedure: dynamic-link filename
     Find the shared object (shared library) denoted by FILENAME and
     link it into the running Guile application.  The returned scheme
     object is a "handle" for the library which can be passed to
     `dynamic-func', `dynamic-call' etc.

     Searching for object files is system dependent.  Normally, if
     FILENAME does have an explicit directory it will be searched for
     in locations such as `/usr/lib' and `/usr/local/lib'.

   dynamic-object?

 -- Scheme Procedure: dynamic-object? obj
     Return `#t' if OBJ is a dynamic object handle, or `#f' otherwise.

   dynamic-unlink

 -- Scheme Procedure: dynamic-unlink dobj
     Unlink a dynamic object from the application, if possible.  The
     object must have been linked by `dynamic-link', with DOBJ the
     corresponding handle.  After this procedure is called, the handle
     can no longer be used to access the object.

   dynamic-func

 -- Scheme Procedure: dynamic-func name dobj
     Return a "handle" for the function NAME in the shared object
     referred to by DOBJ.  The handle can be passed to `dynamic-call'
     to actually call the function.

     Regardless whether your C compiler prepends an underscore `_' to
     the global names in a program, you should *not* include this
     underscore in NAME since it will be added automatically when
     necessary.

   dynamic-call

 -- Scheme Procedure: dynamic-call func dobj
     Call a C function in a dynamic object.  Two styles of invocation
     are supported:

        * FUNC can be a function handle returned by `dynamic-func'.  In
          this case DOBJ is ignored

        * FUNC can be a string with the name of the function to call,
          with DOBJ the handle of the dynamic object in which to find
          the function.  This is equivalent to

               (dynamic-call (dynamic-func FUNC DOBJ) #f)

     In either case, the function is passed no arguments and its return
     value is ignored.

   dynamic-args-call

 -- Scheme Procedure: dynamic-args-call func dobj args
     Call the C function indicated by FUNC and DOBJ, just like
     `dynamic-call', but pass it some arguments and return its return
     value.  The C function is expected to take two arguments and
     return an `int', just like `main':
          int c_func (int argc, char **argv);

     The parameter ARGS must be a list of strings and is converted into
     an array of `char *'.  The array is passed in ARGV and its size in
     ARGC.  The return value is converted to a Scheme number and
     returned from the call to `dynamic-args-call'.

   chown

 -- Scheme Procedure: chown object owner group
     Change the ownership and group of the file referred to by OBJECT to
     the integer values OWNER and GROUP.  OBJECT can be a string
     containing a file name or, if the platform supports fchown, a port
     or integer file descriptor which is open on the file.  The return
     value is unspecified.

     If OBJECT is a symbolic link, either the ownership of the link or
     the ownership of the referenced file will be changed depending on
     the operating system (lchown is unsupported at present).  If OWNER
     or GROUP is specified as `-1', then that ID is not changed.

   chmod

 -- Scheme Procedure: chmod object mode
     Changes the permissions of the file referred to by OBJ.  OBJ can
     be a string containing a file name or a port or integer file
     descriptor which is open on a file (in which case `fchmod' is used
     as the underlying system call).  MODE specifies the new
     permissions as a decimal number, e.g., `(chmod "foo" #o755)'.  The
     return value is unspecified.

   umask

 -- Scheme Procedure: umask [mode]
     If MODE is omitted, returns a decimal number representing the
     current file creation mask.  Otherwise the file creation mask is
     set to MODE and the previous value is returned.

     E.g., `(umask #o022)' sets the mask to octal 22, decimal 18.

   open-fdes

 -- Scheme Procedure: open-fdes path flags [mode]
     Similar to `open' but return a file descriptor instead of a port.

   open

 -- Scheme Procedure: open path flags [mode]
     Open the file named by PATH for reading and/or writing.  FLAGS is
     an integer specifying how the file should be opened.  MODE is an
     integer specifying the permission bits of the file, if it needs to
     be created, before the umask is applied.  The default is 666 (Unix
     itself has no default).

     FLAGS can be constructed by combining variables using `logior'.
     Basic flags are:

      -- Variable: O_RDONLY
          Open the file read-only.

      -- Variable: O_WRONLY
          Open the file write-only.

      -- Variable: O_RDWR
          Open the file read/write.

      -- Variable: O_APPEND
          Append to the file instead of truncating.

      -- Variable: O_CREAT
          Create the file if it does not already exist.

     See the Unix documentation of the `open' system call for
     additional flags.

   close

 -- Scheme Procedure: close fd_or_port
     Similar to close-port (*note close-port: Closing.), but also works
     on file descriptors.  A side effect of closing a file descriptor
     is that any ports using that file descriptor are moved to a
     different file descriptor and have their revealed counts set to
     zero.

   close-fdes

 -- Scheme Procedure: close-fdes fd
     A simple wrapper for the `close' system call.  Close file
     descriptor FD, which must be an integer.  Unlike close (*note
     close: Ports and File Descriptors.), the file descriptor will be
     closed even if a port is using it.  The return value is
     unspecified.

   stat

 -- Scheme Procedure: stat object
     Return an object containing various information about the file
     determined by OBJ.  OBJ can be a string containing a file name or
     a port or integer file descriptor which is open on a file (in
     which case `fstat' is used as the underlying system call).

     The object returned by `stat' can be passed as a single parameter
     to the following procedures, all of which return integers:

    `stat:dev'
          The device containing the file.

    `stat:ino'
          The file serial number, which distinguishes this file from all
          other files on the same device.

    `stat:mode'
          The mode of the file.  This includes file type information and
          the file permission bits.  See `stat:type' and `stat:perms'
          below.

    `stat:nlink'
          The number of hard links to the file.

    `stat:uid'
          The user ID of the file's owner.

    `stat:gid'
          The group ID of the file.

    `stat:rdev'
          Device ID; this entry is defined only for character or block
          special files.

    `stat:size'
          The size of a regular file in bytes.

    `stat:atime'
          The last access time for the file.

    `stat:mtime'
          The last modification time for the file.

    `stat:ctime'
          The last modification time for the attributes of the file.

    `stat:blksize'
          The optimal block size for reading or writing the file, in
          bytes.

    `stat:blocks'
          The amount of disk space that the file occupies measured in
          units of 512 byte blocks.

     In addition, the following procedures return the information from
     stat:mode in a more convenient form:

    `stat:type'
          A symbol representing the type of file.  Possible values are
          regular, directory, symlink, block-special, char-special,
          fifo, socket and unknown

    `stat:perms'
          An integer representing the access permission bits.

   link

 -- Scheme Procedure: link oldpath newpath
     Creates a new name NEWPATH in the file system for the file named
     by OLDPATH.  If OLDPATH is a symbolic link, the link may or may
     not be followed depending on the system.

   rename-file

 -- Scheme Procedure: rename-file oldname newname
     Renames the file specified by OLDNAME to NEWNAME.  The return
     value is unspecified.

   delete-file

 -- Scheme Procedure: delete-file str
     Deletes (or "unlinks") the file specified by PATH.

   mkdir

 -- Scheme Procedure: mkdir path [mode]
     Create a new directory named by PATH.  If MODE is omitted then the
     permissions of the directory file are set using the current umask.
     Otherwise they are set to the decimal value specified with MODE.
     The return value is unspecified.

   rmdir

 -- Scheme Procedure: rmdir path
     Remove the existing directory named by PATH.  The directory must
     be empty for this to succeed.  The return value is unspecified.

   directory-stream?

 -- Scheme Procedure: directory-stream? obj
     Return a boolean indicating whether OBJECT is a directory stream
     as returned by `opendir'.

   opendir

 -- Scheme Procedure: opendir dirname
     Open the directory specified by PATH and return a directory stream.

   readdir

 -- Scheme Procedure: readdir port
     Return (as a string) the next directory entry from the directory
     stream STREAM.  If there is no remaining entry to be read then the
     end of file object is returned.

   rewinddir

 -- Scheme Procedure: rewinddir port
     Reset the directory port STREAM so that the next call to `readdir'
     will return the first directory entry.

   closedir

 -- Scheme Procedure: closedir port
     Close the directory stream STREAM.  The return value is
     unspecified.

   chdir

 -- Scheme Procedure: chdir str
     Change the current working directory to PATH.  The return value is
     unspecified.

   getcwd

 -- Scheme Procedure: getcwd
     Return the name of the current working directory.

   select

 -- Scheme Procedure: select reads writes excepts [secs [usecs]]
     This procedure has a variety of uses: waiting for the ability to
     provide input, accept output, or the existence of exceptional
     conditions on a collection of ports or file descriptors, or
     waiting for a timeout to occur.  It also returns if interrupted by
     a signal.

     READS, WRITES and EXCEPTS can be lists or vectors, with each
     member a port or a file descriptor.  The value returned is a list
     of three corresponding lists or vectors containing only the
     members which meet the specified requirement.  The ability of port
     buffers to provide input or accept output is taken into account.
     Ordering of the input lists or vectors is not preserved.

     The optional arguments SECS and USECS specify the timeout.  Either
     SECS can be specified alone, as either an integer or a real
     number, or both SECS and USECS can be specified as integers, in
     which case USECS is an additional timeout expressed in
     microseconds.  If SECS is omitted or is `#f' then select will wait
     for as long as it takes for one of the other conditions to be
     satisfied.

     The scsh version of `select' differs as follows: Only vectors are
     accepted for the first three arguments.  The USECS argument is not
     supported.  Multiple values are returned instead of a list.
     Duplicates in the input vectors appear only once in output.  An
     additional `select!' interface is provided.

   fcntl

 -- Scheme Procedure: fcntl object cmd [value]
     Apply COMMAND to the specified file descriptor or the underlying
     file descriptor of the specified port.  VALUE is an optional
     integer argument.

     Values for COMMAND are:

    `F_DUPFD'
          Duplicate a file descriptor

    `F_GETFD'
          Get flags associated with the file descriptor.

    `F_SETFD'
          Set flags associated with the file descriptor to VALUE.

    `F_GETFL'
          Get flags associated with the open file.

    `F_SETFL'
          Set flags associated with the open file to VALUE

    `F_GETOWN'
          Get the process ID of a socket's owner, for `SIGIO' signals.

    `F_SETOWN'
          Set the process that owns a socket to VALUE, for `SIGIO'
          signals.

    `FD_CLOEXEC'
          The value used to indicate the "close on exec" flag with
          `F_GETFL' or `F_SETFL'.

   fsync

 -- Scheme Procedure: fsync object
     Copies any unwritten data for the specified output file descriptor
     to disk.  If PORT/FD is a port, its buffer is flushed before the
     underlying file descriptor is fsync'd.  The return value is
     unspecified.

   symlink

 -- Scheme Procedure: symlink oldpath newpath
     Create a symbolic link named PATH-TO with the value (i.e.,
     pointing to) PATH-FROM.  The return value is unspecified.

   readlink

 -- Scheme Procedure: readlink path
     Return the value of the symbolic link named by PATH (a string),
     i.e., the file that the link points to.

   lstat

 -- Scheme Procedure: lstat str
     Similar to `stat', but does not follow symbolic links, i.e., it
     will return information about a symbolic link itself, not the file
     it points to.  PATH must be a string.

   copy-file

 -- Scheme Procedure: copy-file oldfile newfile
     Copy the file specified by PATH-FROM to PATH-TO.  The return value
     is unspecified.

   dirname

 -- Scheme Procedure: dirname filename
     Return the directory name component of the file name FILENAME. If
     FILENAME does not contain a directory component, `.' is returned.

   basename

 -- Scheme Procedure: basename filename [suffix]
     Return the base name of the file name FILENAME. The base name is
     the file name without any directory components.  If SUFFIX is
     provided, and is equal to the end of BASENAME, it is removed also.

   pipe

 -- Scheme Procedure: pipe
     Return a newly created pipe: a pair of ports which are linked
     together on the local machine.  The _car_ is the input port and
     the _cdr_ is the output port.  Data written (and flushed) to the
     output port can be read from the input port.  Pipes are commonly
     used for communication with a newly forked child process.  The
     need to flush the output port can be avoided by making it
     unbuffered using `setvbuf'.

     Writes occur atomically provided the size of the data in bytes is
     not greater than the value of `PIPE_BUF'.  Note that the output
     port is likely to block if too much data (typically equal to
     `PIPE_BUF') has been written but not yet read from the input port.

   getgroups

 -- Scheme Procedure: getgroups
     Return a vector of integers representing the current supplementary
     group IDs.

   getpw

 -- Scheme Procedure: getpw [user]
     Look up an entry in the user database.  OBJ can be an integer, a
     string, or omitted, giving the behaviour of getpwuid, getpwnam or
     getpwent respectively.

   setpw

 -- Scheme Procedure: setpw [arg]
     If called with a true argument, initialize or reset the password
     data stream.  Otherwise, close the stream.  The `setpwent' and
     `endpwent' procedures are implemented on top of this.

   getgr

 -- Scheme Procedure: getgr [name]
     Look up an entry in the group database.  OBJ can be an integer, a
     string, or omitted, giving the behaviour of getgrgid, getgrnam or
     getgrent respectively.

   setgr

 -- Scheme Procedure: setgr [arg]
     If called with a true argument, initialize or reset the group data
     stream.  Otherwise, close the stream.  The `setgrent' and
     `endgrent' procedures are implemented on top of this.

   kill

 -- Scheme Procedure: kill pid sig
     Sends a signal to the specified process or group of processes.

     PID specifies the processes to which the signal is sent:

    PID greater than 0
          The process whose identifier is PID.

    PID equal to 0
          All processes in the current process group.

    PID less than -1
          The process group whose identifier is -PID

    PID equal to -1
          If the process is privileged, all processes except for some
          special system processes.  Otherwise, all processes with the
          current effective user ID.

     SIG should be specified using a variable corresponding to the Unix
     symbolic name, e.g.,

      -- Variable: SIGHUP
          Hang-up signal.

      -- Variable: SIGINT
          Interrupt signal.

   waitpid

 -- Scheme Procedure: waitpid pid [options]
     This procedure collects status information from a child process
     which has terminated or (optionally) stopped.  Normally it will
     suspend the calling process until this can be done.  If more than
     one child process is eligible then one will be chosen by the
     operating system.

     The value of PID determines the behaviour:

    PID greater than 0
          Request status information from the specified child process.

    PID equal to -1 or WAIT_ANY
          Request status information for any child process.

    PID equal to 0 or WAIT_MYPGRP
          Request status information for any child process in the
          current process group.

    PID less than -1
          Request status information for any child process whose
          process group ID is -PID.

     The OPTIONS argument, if supplied, should be the bitwise OR of the
     values of zero or more of the following variables:

      -- Variable: WNOHANG
          Return immediately even if there are no child processes to be
          collected.

      -- Variable: WUNTRACED
          Report status information for stopped processes as well as
          terminated processes.

     The return value is a pair containing:

       1. The process ID of the child process, or 0 if `WNOHANG' was
          specified and no process was collected.

       2. The integer status value.

   status:exit-val

 -- Scheme Procedure: status:exit-val status
     Return the exit status value, as would be set if a process ended
     normally through a call to `exit' or `_exit', if any, otherwise
     `#f'.

   status:term-sig

 -- Scheme Procedure: status:term-sig status
     Return the signal number which terminated the process, if any,
     otherwise `#f'.

   status:stop-sig

 -- Scheme Procedure: status:stop-sig status
     Return the signal number which stopped the process, if any,
     otherwise `#f'.

   getppid

 -- Scheme Procedure: getppid
     Return an integer representing the process ID of the parent
     process.

   getuid

 -- Scheme Procedure: getuid
     Return an integer representing the current real user ID.

   getgid

 -- Scheme Procedure: getgid
     Return an integer representing the current real group ID.

   geteuid

 -- Scheme Procedure: geteuid
     Return an integer representing the current effective user ID.  If
     the system does not support effective IDs, then the real ID is
     returned.  `(provided? 'EIDs)' reports whether the system supports
     effective IDs.

   getegid

 -- Scheme Procedure: getegid
     Return an integer representing the current effective group ID.  If
     the system does not support effective IDs, then the real ID is
     returned.  `(provided? 'EIDs)' reports whether the system supports
     effective IDs.

   setuid

 -- Scheme Procedure: setuid id
     Sets both the real and effective user IDs to the integer ID,
     provided the process has appropriate privileges.  The return value
     is unspecified.

   setgid

 -- Scheme Procedure: setgid id
     Sets both the real and effective group IDs to the integer ID,
     provided the process has appropriate privileges.  The return value
     is unspecified.

   seteuid

 -- Scheme Procedure: seteuid id
     Sets the effective user ID to the integer ID, provided the process
     has appropriate privileges.  If effective IDs are not supported,
     the real ID is set instead - `(provided? 'EIDs)' reports whether
     the system supports effective IDs.  The return value is
     unspecified.

   setegid

 -- Scheme Procedure: setegid id
     Sets the effective group ID to the integer ID, provided the process
     has appropriate privileges.  If effective IDs are not supported,
     the real ID is set instead - `(provided? 'EIDs)' reports whether
     the system supports effective IDs.  The return value is
     unspecified.

   getpgrp

 -- Scheme Procedure: getpgrp
     Return an integer representing the current process group ID.  This
     is the POSIX definition, not BSD.

   setpgid

 -- Scheme Procedure: setpgid pid pgid
     Move the process PID into the process group PGID.  PID or PGID
     must be integers: they can be zero to indicate the ID of the
     current process.  Fails on systems that do not support job control.
     The return value is unspecified.

   setsid

 -- Scheme Procedure: setsid
     Creates a new session.  The current process becomes the session
     leader and is put in a new process group.  The process will be
     detached from its controlling terminal if it has one.  The return
     value is an integer representing the new process group ID.

   ttyname

 -- Scheme Procedure: ttyname port
     Return a string with the name of the serial terminal device
     underlying PORT.

   ctermid

 -- Scheme Procedure: ctermid
     Return a string containing the file name of the controlling
     terminal for the current process.

   tcgetpgrp

 -- Scheme Procedure: tcgetpgrp port
     Return the process group ID of the foreground process group
     associated with the terminal open on the file descriptor
     underlying PORT.

     If there is no foreground process group, the return value is a
     number greater than 1 that does not match the process group ID of
     any existing process group.  This can happen if all of the
     processes in the job that was formerly the foreground job have
     terminated, and no other job has yet been moved into the
     foreground.

   tcsetpgrp

 -- Scheme Procedure: tcsetpgrp port pgid
     Set the foreground process group ID for the terminal used by the
     file descriptor underlying PORT to the integer PGID.  The calling
     process must be a member of the same session as PGID and must have
     the same controlling terminal.  The return value is unspecified.

   execl

 -- Scheme Procedure: execl filename . args
     Executes the file named by PATH as a new process image.  The
     remaining arguments are supplied to the process; from a C program
     they are accessible as the `argv' argument to `main'.
     Conventionally the first ARG is the same as PATH.  All arguments
     must be strings.

     If ARG is missing, PATH is executed with a null argument list,
     which may have system-dependent side-effects.

     This procedure is currently implemented using the `execv' system
     call, but we call it `execl' because of its Scheme calling
     interface.

   execlp

 -- Scheme Procedure: execlp filename . args
     Similar to `execl', however if FILENAME does not contain a slash
     then the file to execute will be located by searching the
     directories listed in the `PATH' environment variable.

     This procedure is currently implemented using the `execvp' system
     call, but we call it `execlp' because of its Scheme calling
     interface.

   execle

 -- Scheme Procedure: execle filename env . args
     Similar to `execl', but the environment of the new process is
     specified by ENV, which must be a list of strings as returned by
     the `environ' procedure.

     This procedure is currently implemented using the `execve' system
     call, but we call it `execle' because of its Scheme calling
     interface.

   primitive-fork

 -- Scheme Procedure: primitive-fork
     Creates a new "child" process by duplicating the current "parent"
     process.  In the child the return value is 0.  In the parent the
     return value is the integer process ID of the child.

     This procedure has been renamed from `fork' to avoid a naming
     conflict with the scsh fork.

   uname

 -- Scheme Procedure: uname
     Return an object with some information about the computer system
     the program is running on.

   environ

 -- Scheme Procedure: environ [env]
     If ENV is omitted, return the current environment (in the Unix
     sense) as a list of strings.  Otherwise set the current
     environment, which is also the default environment for child
     processes, to the supplied list of strings.  Each member of ENV
     should be of the form `NAME=VALUE' and values of `NAME' should not
     be duplicated.  If ENV is supplied then the return value is
     unspecified.

   tmpnam

 -- Scheme Procedure: tmpnam
     Return a name in the file system that does not match any existing
     file.  However there is no guarantee that another process will not
     create the file after `tmpnam' is called.  Care should be taken if
     opening the file, e.g., use the `O_EXCL' open flag or use
     `mkstemp!' instead.

   mkstemp!

 -- Scheme Procedure: mkstemp! tmpl
     Create a new unique file in the file system and return a new
     buffered port open for reading and writing to the file.

     TMPL is a string specifying where the file should be created: it
     must end with `XXXXXX' and those `X's will be changed in the
     string to return the name of the file.  (`port-filename' on the
     port also gives the name.)

     POSIX doesn't specify the permissions mode of the file, on GNU and
     most systems it's `#o600'.  An application can use `chmod' to
     relax that if desired.  For example `#o666' less `umask', which is
     usual for ordinary file creation,

          (let ((port (mkstemp! (string-copy "/tmp/myfile-XXXXXX"))))
            (chmod port (logand #o666 (lognot (umask))))
            ...)

   utime

 -- Scheme Procedure: utime pathname [actime [modtime]]
     `utime' sets the access and modification times for the file named
     by PATH.  If ACTIME or MODTIME is not supplied, then the current
     time is used.  ACTIME and MODTIME must be integer time values as
     returned by the `current-time' procedure.
          (utime "foo" (- (current-time) 3600))
     will set the access time to one hour in the past and the
     modification time to the current time.

   access?

 -- Scheme Procedure: access? path how
     Test accessibility of a file under the real UID and GID of the
     calling process.  The return is `#t' if PATH exists and the
     permissions requested by HOW are all allowed, or `#f' if not.

     HOW is an integer which is one of the following values, or a
     bitwise-OR (`logior') of multiple values.

      -- Variable: R_OK
          Test for read permission.

      -- Variable: W_OK
          Test for write permission.

      -- Variable: X_OK
          Test for execute permission.

      -- Variable: F_OK
          Test for existence of the file.  This is implied by each of
          the other tests, so there's no need to combine it with them.

     It's important to note that `access?' does not simply indicate
     what will happen on attempting to read or write a file.  In normal
     circumstances it does, but in a set-UID or set-GID program it
     doesn't because `access?' tests the real ID, whereas an open or
     execute attempt uses the effective ID.

     A program which will never run set-UID/GID can ignore the
     difference between real and effective IDs, but for maximum
     generality, especially in library functions, it's best not to use
     `access?' to predict the result of an open or execute, instead
     simply attempt that and catch any exception.

     The main use for `access?' is to let a set-UID/GID program
     determine what the invoking user would have been allowed to do,
     without the greater (or perhaps lesser) privileges afforded by the
     effective ID.  For more on this, see "Testing File Access" in The
     GNU C Library Reference Manual.

   getpid

 -- Scheme Procedure: getpid
     Return an integer representing the current process ID.

   putenv

 -- Scheme Procedure: putenv str
     Modifies the environment of the current process, which is also the
     default environment inherited by child processes.

     If STRING is of the form `NAME=VALUE' then it will be written
     directly into the environment, replacing any existing environment
     string with name matching `NAME'.  If STRING does not contain an
     equal sign, then any existing string with name matching STRING will
     be removed.

     The return value is unspecified.

   setlocale

 -- Scheme Procedure: setlocale category [locale]
     If LOCALE is omitted, return the current value of the specified
     locale category as a system-dependent string.  CATEGORY should be
     specified using the values `LC_COLLATE', `LC_ALL' etc.

     Otherwise the specified locale category is set to the string
     LOCALE and the new value is returned as a system-dependent string.
     If LOCALE is an empty string, the locale will be set using
     environment variables.

   mknod

 -- Scheme Procedure: mknod path type perms dev
     Creates a new special file, such as a file corresponding to a
     device.  PATH specifies the name of the file.  TYPE should be one
     of the following symbols: regular, directory, symlink,
     block-special, char-special, fifo, or socket.  PERMS (an integer)
     specifies the file permissions.  DEV (an integer) specifies which
     device the special file refers to.  Its exact interpretation
     depends on the kind of special file being created.

     E.g.,
          (mknod "/dev/fd0" 'block-special #o660 (+ (* 2 256) 2))

     The return value is unspecified.

   nice

 -- Scheme Procedure: nice incr
     Increment the priority of the current process by INCR.  A higher
     priority value means that the process runs less often.  The return
     value is unspecified.

   sync

 -- Scheme Procedure: sync
     Flush the operating system disk buffers.  The return value is
     unspecified.

   crypt

 -- Scheme Procedure: crypt key salt
     Encrypt KEY using SALT as the salt value to the crypt(3) library
     call.

   chroot

 -- Scheme Procedure: chroot path
     Change the root directory to that specified in PATH.  This
     directory will be used for path names beginning with `/'.  The
     root directory is inherited by all children of the current
     process.  Only the superuser may change the root directory.

   getlogin

 -- Scheme Procedure: getlogin
     Return a string containing the name of the user logged in on the
     controlling terminal of the process, or `#f' if this information
     cannot be obtained.

   cuserid

 -- Scheme Procedure: cuserid
     Return a string containing a user name associated with the
     effective user id of the process.  Return `#f' if this information
     cannot be obtained.

   getpass

 -- Scheme Procedure: getpass prompt
     Display PROMPT to the standard error output and read a password
     from `/dev/tty'.  If this file is not accessible, it reads from
     standard input.  The password may be up to 127 characters in
     length.  Additional characters and the terminating newline
     character are discarded.  While reading the password, echoing and
     the generation of signals by special characters is disabled.

   gethostname

 -- Scheme Procedure: gethostname
     Return the host name of the current processor.

   gethost

 -- Scheme Procedure: gethost [host]
 -- Scheme Procedure: gethostbyname hostname
 -- Scheme Procedure: gethostbyaddr address
     Look up a host by name or address, returning a host object.  The
     `gethost' procedure will accept either a string name or an integer
     address; if given no arguments, it behaves like `gethostent' (see
     below).  If a name or address is supplied but the address can not
     be found, an error will be thrown to one of the keys:
     `host-not-found', `try-again', `no-recovery' or `no-data',
     corresponding to the equivalent `h_error' values.  Unusual
     conditions may result in errors thrown to the `system-error' or
     `misc_error' keys.

   sethost

 -- Scheme Procedure: sethost [stayopen]
     If STAYOPEN is omitted, this is equivalent to `endhostent'.
     Otherwise it is equivalent to `sethostent stayopen'.

   htons

 -- Scheme Procedure: htons value
     Convert a 16 bit quantity from host to network byte ordering.
     VALUE is packed into 2 bytes, which are then converted and
     returned as a new integer.

   ntohs

 -- Scheme Procedure: ntohs value
     Convert a 16 bit quantity from network to host byte ordering.
     VALUE is packed into 2 bytes, which are then converted and
     returned as a new integer.

   htonl

 -- Scheme Procedure: htonl value
     Convert a 32 bit quantity from host to network byte ordering.
     VALUE is packed into 4 bytes, which are then converted and
     returned as a new integer.

   ntohl

 -- Scheme Procedure: ntohl value
     Convert a 32 bit quantity from network to host byte ordering.
     VALUE is packed into 4 bytes, which are then converted and
     returned as a new integer.

   inet-aton

 -- Scheme Procedure: inet-aton address
     Convert an IPv4 Internet address from printable string (dotted
     decimal notation) to an integer.  E.g.,

          (inet-aton "127.0.0.1") => 2130706433

   inet-ntoa

 -- Scheme Procedure: inet-ntoa inetid
     Convert an IPv4 Internet address to a printable (dotted decimal
     notation) string.  E.g.,

          (inet-ntoa 2130706433) => "127.0.0.1"

   inet-netof

 -- Scheme Procedure: inet-netof address
     Return the network number part of the given IPv4 Internet address.
     E.g.,

          (inet-netof 2130706433) => 127

   inet-makeaddr

 -- Scheme Procedure: inet-makeaddr net lna
     Make an IPv4 Internet address by combining the network number NET
     with the local-address-within-network number LNA.  E.g.,

          (inet-makeaddr 127 1) => 2130706433

   socket

 -- Scheme Procedure: socket family style proto
     Return a new socket port of the type specified by FAMILY, STYLE
     and PROTO.  All three parameters are integers.  Supported values
     for FAMILY are `AF_UNIX', `AF_INET' and `AF_INET6'.  Typical
     values for STYLE are `SOCK_STREAM', `SOCK_DGRAM' and `SOCK_RAW'.

     PROTO can be obtained from a protocol name using `getprotobyname'.
     A value of zero specifies the default protocol, which is usually
     right.

     A single socket port cannot by used for communication until it has
     been connected to another socket.

   socketpair

 -- Scheme Procedure: socketpair family style proto
     Return a pair of connected (but unnamed) socket ports of the type
     specified by FAMILY, STYLE and PROTO.  Many systems support only
     socket pairs of the `AF_UNIX' family.  Zero is likely to be the
     only meaningful value for PROTO.

   getsockopt

 -- Scheme Procedure: getsockopt sock level optname
     Return an option value from socket port SOCK.

     LEVEL is an integer specifying a protocol layer, either
     `SOL_SOCKET' for socket level options, or a protocol number from
     the `IPPROTO' constants or `getprotoent' (*note Network
     Databases::).

      -- Variable: SOL_SOCKET
      -- Variable: IPPROTO_IP
      -- Variable: IPPROTO_TCP
      -- Variable: IPPROTO_UDP

     OPTNAME is an integer specifying an option within the protocol
     layer.

     For `SOL_SOCKET' level the following OPTNAMEs are defined (when
     provided by the system).  For their meaning see *note Socket-Level
     Options: (libc)Socket-Level Options, or `man 7 socket'.

      -- Variable: SO_DEBUG
      -- Variable: SO_REUSEADDR
      -- Variable: SO_STYLE
      -- Variable: SO_TYPE
      -- Variable: SO_ERROR
      -- Variable: SO_DONTROUTE
      -- Variable: SO_BROADCAST
      -- Variable: SO_SNDBUF
      -- Variable: SO_RCVBUF
      -- Variable: SO_KEEPALIVE
      -- Variable: SO_OOBINLINE
      -- Variable: SO_NO_CHECK
      -- Variable: SO_PRIORITY
          The value returned is an integer.

      -- Variable: SO_LINGER
          The VALUE returned is a pair of integers `(ENABLE .
          TIMEOUT)'.  On old systems without timeout support (ie.
          without `struct linger'), only ENABLE has an effect but the
          value in Guile is always a pair.

   setsockopt

 -- Scheme Procedure: setsockopt sock level optname value
     Set an option on socket port SOCK.  The return value is
     unspecified.

     LEVEL is an integer specifying a protocol layer, either
     `SOL_SOCKET' for socket level options, or a protocol number from
     the `IPPROTO' constants or `getprotoent' (*note Network
     Databases::).

      -- Variable: SOL_SOCKET
      -- Variable: IPPROTO_IP
      -- Variable: IPPROTO_TCP
      -- Variable: IPPROTO_UDP

     OPTNAME is an integer specifying an option within the protocol
     layer.

     For `SOL_SOCKET' level the following OPTNAMEs are defined (when
     provided by the system).  For their meaning see *note Socket-Level
     Options: (libc)Socket-Level Options, or `man 7 socket'.

      -- Variable: SO_DEBUG
      -- Variable: SO_REUSEADDR
      -- Variable: SO_STYLE
      -- Variable: SO_TYPE
      -- Variable: SO_ERROR
      -- Variable: SO_DONTROUTE
      -- Variable: SO_BROADCAST
      -- Variable: SO_SNDBUF
      -- Variable: SO_RCVBUF
      -- Variable: SO_KEEPALIVE
      -- Variable: SO_OOBINLINE
      -- Variable: SO_NO_CHECK
      -- Variable: SO_PRIORITY
          VALUE is an integer.

      -- Variable: SO_LINGER
          VALUE is a pair of integers `(ENABLE . TIMEOUT)'.  On old
          systems without timeout support (ie. without `struct
          linger'), only ENABLE has an effect but the value in Guile is
          always a pair.

     For IP level (`IPPROTO_IP') the following OPTNAMEs are defined
     (when provided by the system).  See `man ip' for what they mean.

      -- Variable: IP_ADD_MEMBERSHIP
      -- Variable: IP_DROP_MEMBERSHIP
          These can be used only with `setsockopt', not `getsockopt'.
          VALUE is a pair `(MULTIADDR . INTERFACEADDR)' of IPv4
          addresses (*note Network Address Conversion::).  MULTIADDR is
          a multicast address to be added to or dropped from the
          interface INTERFACEADDR.  INTERFACEADDR can be `INADDR_ANY'
          to have the system select the interface.  INTERFACEADDR can
          also be an interface index number, on systems supporting that.

   shutdown

 -- Scheme Procedure: shutdown sock how
     Sockets can be closed simply by using `close-port'. The `shutdown'
     procedure allows reception or transmission on a connection to be
     shut down individually, according to the parameter HOW:

    0
          Stop receiving data for this socket.  If further data
          arrives,  reject it.

    1
          Stop trying to transmit data from this socket.  Discard any
          data waiting to be sent.  Stop looking for acknowledgement of
          data already sent; don't retransmit it if it is lost.

    2
          Stop both reception and transmission.

     The return value is unspecified.

   connect

 -- Scheme Procedure: connect sock fam_or_sockaddr [address . args]
     Initiate a connection from a socket using a specified address
     family to the address specified by ADDRESS and possibly ARGS.  The
     format required for ADDRESS and ARGS depends on the family of the
     socket.

     For a socket of family `AF_UNIX', only ADDRESS is specified and
     must be a string with the filename where the socket is to be
     created.

     For a socket of family `AF_INET', ADDRESS must be an integer IPv4
     host address and ARGS must be a single integer port number.

     For a socket of family `AF_INET6', ADDRESS must be an integer IPv6
     host address and ARGS may be up to three integers: port [flowinfo]
     [scope_id], where flowinfo and scope_id default to zero.

     Alternatively, the second argument can be a socket address object
     as returned by `make-socket-address', in which case the no
     additional arguments should be passed.

     The return value is unspecified.

   bind

 -- Scheme Procedure: bind sock fam_or_sockaddr [address . args]
     Assign an address to the socket port SOCK.  Generally this only
     needs to be done for server sockets, so they know where to look
     for incoming connections.  A socket without an address will be
     assigned one automatically when it starts communicating.

     The format of ADDRESS and ARGS depends on the family of the socket.

     For a socket of family `AF_UNIX', only ADDRESS is specified and
     must be a string with the filename where the socket is to be
     created.

     For a socket of family `AF_INET', ADDRESS must be an integer IPv4
     address and ARGS must be a single integer port number.

     The values of the following variables can also be used for ADDRESS:

      -- Variable: INADDR_ANY
          Allow connections from any address.

      -- Variable: INADDR_LOOPBACK
          The address of the local host using the loopback device.

      -- Variable: INADDR_BROADCAST
          The broadcast address on the local network.

      -- Variable: INADDR_NONE
          No address.

     For a socket of family `AF_INET6', ADDRESS must be an integer IPv6
     address and ARGS may be up to three integers: port [flowinfo]
     [scope_id], where flowinfo and scope_id default to zero.

     Alternatively, the second argument can be a socket address object
     as returned by `make-socket-address', in which case the no
     additional arguments should be passed.

     The return value is unspecified.

   listen

 -- Scheme Procedure: listen sock backlog
     Enable SOCK to accept connection requests.  BACKLOG is an integer
     specifying the maximum length of the queue for pending connections.
     If the queue fills, new clients will fail to connect until the
     server calls `accept' to accept a connection from the queue.

     The return value is unspecified.

   make-socket-address

 -- Scheme Procedure: make-socket-address family address . args
     Return a Scheme address object that reflects ADDRESS, being an
     address of family FAMILY, with the family-specific parameters ARGS
     (see the description of `connect' for details).

   accept

 -- Scheme Procedure: accept sock
     Accept a connection on a bound, listening socket.  If there are no
     pending connections in the queue, wait until one is available
     unless the non-blocking option has been set on the socket.

     The return value is a pair in which the _car_ is a new socket port
     for the connection and the _cdr_ is an object with address
     information about the client which initiated the connection.

     SOCK does not become part of the connection and will continue to
     accept new requests.

   getsockname

 -- Scheme Procedure: getsockname sock
     Return the address of SOCK, in the same form as the object
     returned by `accept'.  On many systems the address of a socket in
     the `AF_FILE' namespace cannot be read.

   getpeername

 -- Scheme Procedure: getpeername sock
     Return the address that SOCK is connected to, in the same form as
     the object returned by `accept'.  On many systems the address of a
     socket in the `AF_FILE' namespace cannot be read.

   recv!

 -- Scheme Procedure: recv! sock buf [flags]
     Receive data from a socket port.  SOCK must already be bound to
     the address from which data is to be received.  BUF is a string
     into which the data will be written.  The size of BUF limits the
     amount of data which can be received: in the case of packet
     protocols, if a packet larger than this limit is encountered then
     some data will be irrevocably lost.

     The optional FLAGS argument is a value or bitwise OR of MSG_OOB,
     MSG_PEEK, MSG_DONTROUTE etc.

     The value returned is the number of bytes read from the socket.

     Note that the data is read directly from the socket file
     descriptor: any unread buffered port data is ignored.

   send

 -- Scheme Procedure: send sock message [flags]
     Transmit the string MESSAGE on a socket port SOCK.  SOCK must
     already be bound to a destination address.  The value returned is
     the number of bytes transmitted - it's possible for this to be
     less than the length of MESSAGE if the socket is set to be
     non-blocking.  The optional FLAGS argument is a value or bitwise
     OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

     Note that the data is written directly to the socket file
     descriptor: any unflushed buffered port data is ignored.

   recvfrom!

 -- Scheme Procedure: recvfrom! sock str [flags [start [end]]]
     Receive data from socket port SOCK (which must be already bound),
     returning the originating address as well as the data.  This is
     usually for use on datagram sockets, but can be used on
     stream-oriented sockets too.

     The data received is stored in the given STR, using either the
     whole string or just the region between the optional START and END
     positions.  The size of STR limits the amount of data which can be
     received.  For datagram protocols, if a packet larger than this is
     received then excess bytes are irrevocably lost.

     The return value is a pair.  The `car' is the number of bytes
     read.  The `cdr' is a socket address object which is where the
     data come from, or `#f' if the origin is unknown.

     The optional FLAGS argument is a or bitwise OR (`logior') of
     `MSG_OOB', `MSG_PEEK', `MSG_DONTROUTE' etc.

     Data is read directly from the socket file descriptor, any
     buffered port data is ignored.

     On a GNU/Linux system `recvfrom!' is not multi-threading, all
     threads stop while a `recvfrom!' call is in progress.  An
     application may need to use `select', `O_NONBLOCK' or
     `MSG_DONTWAIT' to avoid this.

   sendto

 -- Scheme Procedure: sendto sock message fam_or_sockaddr [address .
          args_and_flags]
     Transmit the string MESSAGE on the socket port SOCK.  The
     destination address is specified using the FAM, ADDRESS and
     ARGS_AND_FLAGS arguments, or just a socket address object returned
     by `make-socket-address', in a similar way to the `connect'
     procedure.  ARGS_AND_FLAGS contains the usual connection arguments
     optionally followed by a flags argument, which is a value or
     bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

     The value returned is the number of bytes transmitted - it's
     possible for this to be less than the length of MESSAGE if the
     socket is set to be non-blocking.  Note that the data is written
     directly to the socket file descriptor: any unflushed buffered
     port data is ignored.

   regexp?

 -- Scheme Procedure: regexp? obj
     Return `#t' if OBJ is a compiled regular expression, or `#f'
     otherwise.

   make-regexp

 -- Scheme Procedure: make-regexp pat . flags
     Compile the regular expression described by PAT, and return the
     compiled regexp structure.  If PAT does not describe a legal
     regular expression, `make-regexp' throws a
     `regular-expression-syntax' error.

     The FLAGS arguments change the behavior of the compiled regular
     expression.  The following flags may be supplied:

    `regexp/icase'
          Consider uppercase and lowercase letters to be the same when
          matching.

    `regexp/newline'
          If a newline appears in the target string, then permit the
          `^' and `$' operators to match immediately after or
          immediately before the newline, respectively.  Also, the `.'
          and `[^...]' operators will never match a newline character.
          The intent of this flag is to treat the target string as a
          buffer containing many lines of text, and the regular
          expression as a pattern that may match a single one of those
          lines.

    `regexp/basic'
          Compile a basic ("obsolete") regexp instead of the extended
          ("modern") regexps that are the default.  Basic regexps do
          not consider `|', `+' or `?' to be special characters, and
          require the `{...}' and `(...)' metacharacters to be
          backslash-escaped (*note Backslash Escapes::).  There are
          several other differences between basic and extended regular
          expressions, but these are the most significant.

    `regexp/extended'
          Compile an extended regular expression rather than a basic
          regexp.  This is the default behavior; this flag will not
          usually be needed.  If a call to `make-regexp' includes both
          `regexp/basic' and `regexp/extended' flags, the one which
          comes last will override the earlier one.

   regexp-exec

 -- Scheme Procedure: regexp-exec rx str [start [flags]]
     Match the compiled regular expression RX against `str'.  If the
     optional integer START argument is provided, begin matching from
     that position in the string.  Return a match structure describing
     the results of the match, or `#f' if no match could be found.

     The FLAGS arguments change the matching behavior.  The following
     flags may be supplied:

    `regexp/notbol'
          Operator `^' always fails (unless `regexp/newline' is used).
          Use this when the beginning of the string should not be
          considered the beginning of a line.

    `regexp/noteol'
          Operator `$' always fails (unless `regexp/newline' is used).
          Use this when the end of the string should not be considered
          the end of a line.

