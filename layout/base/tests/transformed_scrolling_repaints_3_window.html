<!DOCTYPE HTML>
<html>
<head>
  <title>Test that scaled elements with scrolled contents don't repaint unnecessarily when we scroll inside them</title>
  <script type="text/javascript" src="/tests/SimpleTest/paint_listener.js"></script>
</head>
<!-- Need a timeout here to allow paint unsuppression before we start the test -->
<body onload="setTimeout(startTest,0)" style="background:white;">
<iframe id="t" style="-moz-transform: scale(0.48979); -moz-transform-origin:top left; width:500px; height:600px;"
        src="transformed_scrolling_repaints_3_window_frame.html">
</iframe>
<pre id="test">
<script type="application/javascript">
var SimpleTest = window.opener.SimpleTest;
var SpecialPowers = window.opener.SpecialPowers;
var is = window.opener.is;
var t, e, utils, iterations;
var smoothScrollPref = "general.smoothScroll";

function startTest() {
  SpecialPowers.pushPrefEnv({"set":[[smoothScrollPref, false]]}, runTest);
}
function runTest() {
    t = document.getElementById("t");
    e = t.contentDocument.getElementById("e");
    t.contentWindow.scrollTo(0,0);
    utils = SpecialPowers.getDOMWindowUtils(window);
    iterations = 0;

  // Do a couple of scrolls to ensure we've triggered activity heuristics.
    waitForAllPaintsFlushed(function () {
      t.contentWindow.scrollByLines(1);
      waitForAllPaintsFlushed(function () {
        t.contentWindow.scrollByLines(1);
        waitForAllPaintsFlushed(function () {
          // Clear paint state now and scroll again.
          utils.checkAndClearPaintedState(e);
          t.contentWindow.scrollByLines(1);
          waitForAllPaintsFlushed(nextIteration);
        });
      });
    });
}
function nextIteration() {
  var painted = utils.checkAndClearPaintedState(e);
  is(painted, false, "Fully-visible scrolled element should not have been painted");
  if (++iterations == 10) {
    SimpleTest.finish();
    window.close();
  } else {
    t.contentWindow.scrollByLines(1);
    waitForAllPaintsFlushed(nextIteration);
  }
}
</script>
</pre>
</body>
</html>
