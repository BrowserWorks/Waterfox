/* -*- Mode: IDL; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "domstubs.idl"
#include "nsIDocShellTreeItem.idl"
#include "nsIRequest.idl"

%{ C++
#include "js/TypeDecls.h"
class nsPresContext;
class nsIPresShell;
%}

/**
 * The nsIDocShell interface.
 */

[ptr] native nsPresContext(nsPresContext);
[ptr] native nsIPresShell(nsIPresShell);

interface nsIURI;
interface nsIChannel;
interface nsIContentViewer;
interface nsIDOMEventTarget;
interface nsIDocShellLoadInfo;
interface nsIEditor;
interface nsIEditingSession;
interface nsISimpleEnumerator;
interface nsIInputStream;
interface nsIRequest;
interface nsISHEntry;
interface nsILayoutHistoryState;
interface nsISecureBrowserUI;
interface nsIScriptGlobalObject;
interface nsIDOMStorage;
interface nsIPrincipal;
interface nsIWebBrowserPrint;
interface nsIPrivacyTransitionObserver;
interface nsIReflowObserver;
interface nsIScrollObserver;
interface nsITabParent;
interface nsITabChild;
interface nsICommandManager;
interface nsICommandParams;
native TabChildRef(already_AddRefed<nsITabChild>);

[scriptable, builtinclass, uuid(049234fe-da10-478b-bc5d-bc6f9a1ba63d)]
interface nsIDocShell : nsIDocShellTreeItem
{
  /**
   * Loads a given URI.  This will give priority to loading the requested URI
   * in the object implementing	this interface.  If it can't be loaded here
   * however, the URL dispatcher will go through its normal process of content
   * loading.
   *
   * @param uri        - The URI to load.
   * @param loadInfo   - This is the extended load info for this load.  This
   *                     most often will be null, but if you need to do
   *                     additional setup for this load you can get a loadInfo
   *                     object by calling createLoadInfo.  Once you have this
   *                     object you can set the needed properties on it and
   *                     then pass it to loadURI.
   * @param aLoadFlags - Flags to modify load behaviour. Flags are defined in
   *                     nsIWebNavigation.  Note that using flags outside
   *                     LOAD_FLAGS_MASK is only allowed if passing in a
   *                     non-null loadInfo.  And even some of those might not
   *                     be allowed.  Use at your own risk.
   */
  [noscript]void loadURI(in nsIURI uri,
                         in nsIDocShellLoadInfo loadInfo,
                         in unsigned long aLoadFlags,
                         in boolean firstParty);

  /**
   * Loads a given stream. This will give priority to loading the requested
   * stream in the object implementing this interface. If it can't be loaded
   * here however, the URL dispatched will go through its normal process of
   * content loading.
   *
   * @param aStream         - The input stream that provides access to the data
   *                          to be loaded.  This must be a blocking, threadsafe
   *                          stream implementation.
   * @param aURI            - The URI representing the stream, or null.
   * @param aContentType    - The type (MIME) of data being loaded (empty if unknown).
   * @param aContentCharset - The charset of the data being loaded (empty if unknown).
   * @param aLoadInfo       - This is the extended load info for this load.  This
   *                          most often will be null, but if you need to do
   *                          additional setup for this load you can get a
   *                          loadInfo object by calling createLoadInfo.  Once
   *                          you have this object you can set the needed
   *                          properties on it and then pass it to loadStream.
   */
  [noscript]void loadStream(in nsIInputStream aStream,
                            in nsIURI aURI,
                            in ACString aContentType,
                            in ACString aContentCharset,
                            in nsIDocShellLoadInfo aLoadInfo);

  const long INTERNAL_LOAD_FLAGS_NONE                    = 0x0;
  const long INTERNAL_LOAD_FLAGS_INHERIT_PRINCIPAL       = 0x1;
  const long INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER      = 0x2;
  const long INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP = 0x4;

  // This flag marks the first load in this object
  // @see nsIWebNavigation::LOAD_FLAGS_FIRST_LOAD
  const long INTERNAL_LOAD_FLAGS_FIRST_LOAD              = 0x8;

  const long INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER       = 0x10;
  const long INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES     = 0x20;

  // Whether the load should be treated as srcdoc load, rather than a URI one.
  const long INTERNAL_LOAD_FLAGS_IS_SRCDOC               = 0x40;

  const long INTERNAL_LOAD_FLAGS_NO_OPENER               = 0x100;

  // NB: 0x80 is available.

  /**
   * Loads the given URI.  This method is identical to loadURI(...) except
   * that its parameter list is broken out instead of being packaged inside
   * of an nsIDocShellLoadInfo object...
   *
   * @param aURI                 - The URI to load.
   * @param aOriginalURI         - The URI to set as the originalURI on the channel
   *                               that does the load. If null, aURI will be set as
   *                               the originalURI.
   * @param aLoadReplace         - If set LOAD_REPLACE flag will be set on the
   *                               channel. aOriginalURI is null, this argument is
   *                               ignored.
   * @param aReferrer            - Referring URI
   * @param aReferrerPolicy      - Referrer policy
   * @param aTriggeringPrincipal - A non-null principal that initiated that load.
   *                               Please note that this is the principal that is
   *                               used for security checks. If the argument aURI
   *                               is provided by the web, then please do not pass
   *                               a SystemPrincipal as the triggeringPrincipal.
   * @param aPrincipalToInherit  - Principal to be inherited for that load. If this
   *                               argument is null then principalToInherit is
   *                               computed as follows:
   *                               a) If INTERNAL_LOAD_FLAGS_INHERIT_PRINCIPAL, and
   *                                  aLoadType is not LOAD_NORMAL_EXTERNAL, and the
   *                                  URI would normally inherit a principal, then
   *                                  principalToInherit is set to the current
   *                                  document's principal, or parent document if
   *                                  there is not a current document.
   *                               b) If principalToInherit is still null (e.g. if
   *                                  some of the conditions of (a) were not satisfied),
   *                                  then no inheritance of any sort will happen: the
   *                                  load will just get a principal based on the URI
   *                                  being loaded.
   * @param aFlags               - Any of the load flags defined within above.
   * @param aStopActiveDoc       - Flag indicating whether loading the current
   *                               document should be stopped.
   * @param aWindowTarget        - Window target for the load.
   * @param aTypeHint            - A hint as to the content-type of the resulting
   *                               data.  May be null or empty if no hint.
   * @param aFileName            - Non-null when the link should be downloaded as
                                   the given filename.
   * @param aPostDataStream      - Post data stream (if POSTing)
   * @param aHeadersStream       - Stream containing "extra" request headers...
   * @param aLoadFlags           - Flags to modify load behaviour. Flags are defined
   *                               in nsIWebNavigation.
   * @param aSHEntry             - Active Session History entry (if loading from SH)
   * @param aSrcdoc                When INTERNAL_LOAD_FLAGS_IS_SRCDOC is set, the
   *                               contents of this parameter will be loaded instead
   *                               of aURI.
   * @param aSourceDocShell      - The source browsing context for the navigation.
   * @param aBaseURI             - The base URI to be used for the load.  Set in
   *                               srcdoc loads as it cannot otherwise be inferred
   *                               in certain situations such as view-source.
   */
  [noscript]void internalLoad(in nsIURI aURI,
                              in nsIURI aOriginalURI,
                              in boolean aLoadReplace,
                              in nsIURI aReferrer,
                              in unsigned long aReferrerPolicy,
                              in nsIPrincipal aTriggeringPrincipal,
                              in nsIPrincipal aPrincipalToInherit,
                              in uint32_t aFlags,
                              in AString aWindowTarget,
                              in string aTypeHint,
                              in AString aFileName,
                              in nsIInputStream aPostDataStream,
                              in nsIInputStream aHeadersStream,
                              in unsigned long aLoadFlags,
                              in nsISHEntry aSHEntry,
                              in boolean firstParty,
                              in AString aSrcdoc,
                              in nsIDocShell aSourceDocShell,
                              in nsIURI aBaseURI,
                              out nsIDocShell aDocShell,
                              out nsIRequest aRequest);

  /**
   * Do either a history.pushState() or history.replaceState() operation,
   * depending on the value of aReplace.
   */
  [implicit_jscontext]
  void addState(in jsval aData, in DOMString aTitle,
                in DOMString aURL, in boolean aReplace);

  /**
   * Creates a DocShellLoadInfo object that you can manipulate and then pass
   * to loadURI.
   */
  void createLoadInfo(out nsIDocShellLoadInfo loadInfo);

  /**
   * Reset state to a new content model within the current document and the document
   * viewer.  Called by the document before initiating an out of band document.write().
   */
  void prepareForNewContentModel();

  /**
   * For editors and suchlike who wish to change the URI associated with the
   * document. Note if you want to get the current URI, use the read-only
   * property on nsIWebNavigation.
   */
  void setCurrentURI(in nsIURI aURI);

  /**
   * Notify the associated content viewer and all child docshells that they are
   * about to be hidden.  If |isUnload| is true, then the document is being
   * unloaded as well.
   *
   * @param isUnload if true, fire the unload event in addition to the pagehide
   *                 event.
   */
  [noscript] void firePageHideNotification(in boolean isUnload);

  /**
   * Presentation context for the currently loaded document.  This may be null.
   */
  [noscript] readonly attribute nsPresContext presContext;

  /**
   * Presentation shell for the currently loaded document.  This may be null.
   */
  [noscript,notxpcom] nsIPresShell GetPresShell();

  /**
   * Presentation shell for the oldest document, if this docshell is
   * currently transitioning between documents.
   */
  [noscript] readonly attribute nsIPresShell eldestPresShell;

  /**
   * Content Viewer that is currently loaded for this DocShell.  This may
   * change as the underlying content changes.
   */
  readonly attribute nsIContentViewer contentViewer;

  /**
   * This attribute allows chrome to tie in to handle DOM events that may
   * be of interest to chrome.
   */
  attribute nsIDOMEventTarget chromeEventHandler;

  /**
    * This allows chrome to set a custom User agent on a specific docshell
    */
  attribute DOMString customUserAgent;

  /**
   * Whether to allow plugin execution
   */
  attribute boolean allowPlugins;

  /**
   * Whether to allow Javascript execution
   */
  attribute boolean allowJavascript;

  /**
   * Attribute stating if refresh based redirects can be allowed
   */
  attribute boolean allowMetaRedirects;

  /**
   * Attribute stating if it should allow subframes (framesets/iframes) or not
   */
  attribute boolean allowSubframes;

  /**
   * Attribute stating whether or not images should be loaded.
   */
  attribute boolean allowImages;

  /**
   * Attribute stating whether or not media (audio/video) should be loaded.
   */
  [infallible] attribute boolean allowMedia;

  /**
   * Attribute that determines whether DNS prefetch is allowed for this subtree
   * of the docshell tree.  Defaults to true.  Setting this will make it take
   * effect starting with the next document loaded in the docshell.
   */
  attribute boolean allowDNSPrefetch;

  /**
   * Attribute that determines whether window control (move/resize) is allowed.
   */
  attribute boolean allowWindowControl;

  /**
   * True if the docshell allows its content to be handled by a content listener
   * other than the docshell itself, including the external helper app service,
   * and false otherwise.  Defaults to true.
   */
  [infallible] attribute boolean allowContentRetargeting;

  /**
   * True if new child docshells should allow content retargeting.
   * Setting allowContentRetargeting also overwrites this value.
   */
  [infallible] attribute boolean allowContentRetargetingOnChildren;

  /**
   * True if this docShell should inherit the private browsing ID from
   * its parent when reparented.
   *
   * NOTE: This should *not* be set false in new code, or for docShells
   * inserted anywhere other than as children of panels.
   */
  [infallible] attribute boolean inheritPrivateBrowsingId;

  /**
   * Get an enumerator over this docShell and its children.
   *
   * @param aItemType  - Only include docShells of this type, or if typeAll,
   *                     include all child shells.
   *                     Uses types from nsIDocShellTreeItem.
   * @param aDirection - Whether to enumerate forwards or backwards.
   */

  const long ENUMERATE_FORWARDS  = 0;
  const long ENUMERATE_BACKWARDS = 1;

  nsISimpleEnumerator getDocShellEnumerator(in long aItemType,
                                            in long aDirection);

  /**
   * The type of application that created this window
   */
  const unsigned long APP_TYPE_UNKNOWN  = 0;
  const unsigned long APP_TYPE_MAIL     = 1;
  const unsigned long APP_TYPE_EDITOR   = 2;

  attribute unsigned long appType;

  /**
   * certain dochshells (like the message pane)
   * should not throw up auth dialogs
   * because it can act as a password trojan
   */
  attribute boolean allowAuth;

  /**
   * Set/Get the document scale factor.  When setting this attribute, a
   * NS_ERROR_NOT_IMPLEMENTED error may be returned by implementations
   * not supporting zoom.  Implementations not supporting zoom should return
   * 1.0 all the time for the Get operation.  1.0 by the way is the default
   * of zoom.  This means 100% of normal scaling or in other words normal size
   * no zoom.
   */
  attribute float zoom;

  /*
   * The size, in CSS pixels, of the horizontal margins for the <body> of an
   * HTML document in this docshel; used to implement the marginwidth attribute
   * on HTML <frame>/<iframe> elements.  A value smaller than zero indicates
   * that the attribute was not set.
   */
  attribute long marginWidth;

  /*
   * The size, in CSS pixels, of the vertical margins for the <body> of an HTML
   * document in this docshel; used to implement the marginheight attribute on
   * HTML <frame>/<iframe> elements.  A value smaller than zero indicates that
   * the attribute was not set.
   */
  attribute long marginHeight;

  /*
   * Tells the docshell to offer focus to its tree owner.
   * This is currently only necessary for embedding chrome.
   * If forDocumentNavigation is true, then document navigation should be
   * performed, where only the root of documents are selected. Otherwise, the
   * next element in the parent should be returned. Returns true if focus was
   * successfully taken by the tree owner.
   */
  bool tabToTreeOwner(in boolean forward, in boolean forDocumentNavigation);

  /**
   * Current busy state for DocShell
   */
  const unsigned long BUSY_FLAGS_NONE             = 0;
  const unsigned long BUSY_FLAGS_BUSY             = 1;
  const unsigned long BUSY_FLAGS_BEFORE_PAGE_LOAD = 2;
  const unsigned long BUSY_FLAGS_PAGE_LOADING     = 4;

  /**
   * Load commands for the document
   */
  const unsigned long LOAD_CMD_NORMAL  = 0x1;   // Normal load
  const unsigned long LOAD_CMD_RELOAD  = 0x2;   // Reload
  const unsigned long LOAD_CMD_HISTORY = 0x4;   // Load from history
  const unsigned long LOAD_CMD_PUSHSTATE = 0x8; // History.pushState()

  readonly attribute unsigned long busyFlags;

  /*
   * attribute to access the loadtype  for the document
   */
  attribute unsigned long  loadType;

  /*
   * Default load flags (as defined in nsIRequest) that will be set on all
   * requests made by this docShell and propagated to all child docShells and
   * to nsILoadGroup::defaultLoadFlags for the docShell's loadGroup.
   * Default is no flags.  Once set, only future requests initiated by the
   * docShell are affected, so in general, these flags should be set before
   * the docShell loads any content.
   */
  attribute nsLoadFlags defaultLoadFlags;

  /*
   * returns true if the docshell is being destroyed, false otherwise
   */
  boolean isBeingDestroyed();

  /*
   * Returns true if the docshell is currently executing the onLoad Handler
   */
  readonly attribute boolean isExecutingOnLoadHandler;

  attribute nsILayoutHistoryState layoutHistoryState;

  readonly attribute boolean shouldSaveLayoutState;

  /**
   * The SecureBrowserUI object for this docshell.  This is set by XUL
   * <browser> or nsWebBrowser for their root docshell.
   */
  attribute nsISecureBrowserUI securityUI;

  /**
   * Cancel the XPCOM timers for each meta-refresh URI in this docshell,
   * and this docshell's children, recursively. The meta-refresh timers can be
   * restarted using resumeRefreshURIs().  If the timers are already suspended,
   * this has no effect.
   */
  void suspendRefreshURIs();

  /**
   * Restart the XPCOM timers for each meta-refresh URI in this docshell,
   * and this docshell's children, recursively.  If the timers are already
   * running, this has no effect.
   */
  void resumeRefreshURIs();

  /**
   * Begin firing WebProgressListener notifications for restoring a page
   * presentation. |viewer| is the content viewer whose document we are
   * starting to load.  If null, it defaults to the docshell's current content
   * viewer, creating one if necessary.  |top| should be true for the toplevel
   * docshell that is being restored; it will be set to false when this method
   * is called for child docshells.  This method will post an event to
   * complete the simulated load after returning to the event loop.
   */
  void beginRestore(in nsIContentViewer viewer, in boolean top);

  /**
   * Finish firing WebProgressListener notifications and DOM events for
   * restoring a page presentation.  This should only be called via
   * beginRestore().
   */
  void finishRestore();

  /* Track whether we're currently restoring a document presentation. */
  readonly attribute boolean restoringDocument;

  /* attribute to access whether error pages are enabled */
  attribute boolean useErrorPages;

  /**
   * Display a load error in a frame while keeping that frame's currentURI
   * pointing correctly to the page where the error ocurred, rather than to
   * the error document page. You must provide either the aURI or aURL parameter.
   *
   * @param  aError         The error code to be displayed
   * @param  aURI           nsIURI of the page where the error happened
   * @param  aURL           wstring of the page where the error happened
   * @param  aFailedChannel The channel related to this error
   *
   * Returns whether or not we displayed an error page (note: will always
   * return false if in-content error pages are disabled!)
   */
  boolean displayLoadError(in nsresult aError,
                           in nsIURI aURI,
                           in wstring aURL,
                           [optional] in nsIChannel aFailedChannel);

  /**
   * The channel that failed to load and resulted in an error page.
   * May be null. Relevant only to error pages.
   */
  readonly attribute nsIChannel failedChannel;

  /**
   * Keeps track of the previous SHTransaction index and the current
   * SHTransaction index at the time that the doc shell begins to load.
   * Used for ContentViewer eviction.
   */
  readonly attribute long previousTransIndex;
  readonly attribute long loadedTransIndex;

  /**
   * Notification that entries have been removed from the beginning of a
   * nsSHistory which has this as its rootDocShell.
   *
   * @param numEntries - The number of entries removed
   */
  void historyPurged(in long numEntries);

  /*
   * @deprecated, use nsIDocShell.QueryInterface(nsIDOMStorageManager) instead.
   *
   * Retrieves the WebApps session storage object for the supplied principal.
   *
   * @param principal returns a storage for this principal
   * @param documentURI new storage will be created with reference to this
   *                    document.documentURI that will appear in storage event
   * @param create If true and a session storage object doesn't
   *               already exist, a new one will be created.
   */
  nsIDOMStorage getSessionStorageForPrincipal(in nsIPrincipal principal,
                                              in DOMString documentURI,
                                              in boolean create);

  /*
   * @deprecated, use nsIDocShell.QueryInterface(nsIDOMStorageManager) instead.
   *
   * Add a WebApps session storage object to the docshell.
   *
   * @param principal the principal the storage object is associated with
   * @param storage the storage object to add
   */
  void addSessionStorage(in nsIPrincipal principal, in nsIDOMStorage storage);

  /**
   * Gets the channel for the currently loaded document, if any.
   * For a new document load, this will be the channel of the previous document
   * until after OnLocationChange fires.
   */
  readonly attribute nsIChannel currentDocumentChannel;

  /**
   * Set the offset of this child in its container.
   */
  [noscript] void setChildOffset(in unsigned long offset);

  /**
   * Find out whether the docshell is currently in the middle of a page
   * transition. This is set just before the pagehide/unload events fire.
   */
  readonly attribute boolean isInUnload;

  /**
   * Find out if the currently loaded document came from a suspicious channel
   * (such as a JAR channel where the server-returned content type isn't a
   * known JAR type).
   */
  readonly attribute boolean channelIsUnsafe;

  /**
   * This attribute determines whether Mixed Active Content is loaded on the
   * document. When it is true, mixed active content was not blocked and has
   * loaded (or is about to load) on the page. When it is false, mixed active content
   * has not loaded on the page, either because there was no mixed active content
   * requests on the page or such requests were blocked by nsMixedContentBlocker.
   * This boolean is set to true in nsMixedContentBlocker if Mixed Active Content
   * is allowed (either explicitly on the page by the user or when the about:config
   * setting security.mixed_content.block_active_content is set to false).
   */
  [infallible] readonly attribute boolean hasMixedActiveContentLoaded;

   /**
   * This attribute determines whether a document has Mixed Active Content
   * that has been blocked from loading. When it is true, there is definitely
   * mixed active content on a page that has been blocked by
   * nsMixedContentBlocker.  When it is false, there may or may not be mixed
   * active content on a page, but if there is, it will load. Note that if the
   * about:config setting security.mixed_content.block_active_content is set
   * false, this boolean will be false, since blocking active content has been
   * disabled.
   */
  [infallible] readonly attribute boolean hasMixedActiveContentBlocked;

  /**
   * This attribute determines whether Mixed Display Content is loaded on the
   * document. When it is true, mixed display content was not blocked and has
   * loaded (or is about to load) on the page. Similar behavior to
   * hasMixedActiveContentLoaded.
   */
  [infallible] readonly attribute boolean hasMixedDisplayContentLoaded;

   /**
   * This attribute determines whether a document has Mixed Display Content
   * that has been blocked from loading. Similar behavior to
   * hasMixedActiveContentBlocked.
   */
  [infallible] readonly attribute boolean hasMixedDisplayContentBlocked;

   /**
   * This attribute determines whether a document has Tracking Content
   * that has been blocked from loading.
   */
   [infallible] readonly attribute boolean hasTrackingContentBlocked;

   /**
   * This attribute determines whether Tracking Content is loaded on the
   * document. When it is true, tracking content was not blocked and has
   * loaded (or is about to load) on the page.
   */
  [infallible] readonly attribute boolean hasTrackingContentLoaded;

  /**
   * Disconnects this docshell's editor from its window, and stores the
   * editor data in the open document's session history entry.  This
   * should be called only during page transitions.
   */
  [noscript, notxpcom] void DetachEditorFromWindow();

  /**
   * If true, this browser is not visible in the traditional sense, but
   * is actively being rendered to the screen (ex. painted on a canvas)
   * and should be treated accordingly.
   **/
  attribute boolean isOffScreenBrowser;

  /**
   * If the current content viewer isn't initialized for print preview,
   * it is replaced with one which is and to which an about:blank document
   * is loaded.
   */
  readonly attribute nsIWebBrowserPrint printPreview;

  /**
   * Whether this docshell can execute scripts based on its hierarchy.
   * The rule of thumb here is that we disable js if this docshell or any
   * of its parents disallow scripting.
   */
  [infallible] readonly attribute boolean canExecuteScripts;

  /**
   * Sets whether a docshell is active. An active docshell is one that is
   * visible, and thus is not a good candidate for certain optimizations
   * like image frame discarding. Docshells are active unless told otherwise.
   */
  attribute boolean isActive;

  /**
   * Puts the docshell in prerendering mode. noscript because we want only
   * native code to be able to put a docshell in prerendering.
   */
  [noscript] void SetIsPrerendered();

  /**
   * Whether this docshell is in prerender mode.
   */
  [infallible] readonly attribute boolean isPrerendered;

  /**
   * The ID of the docshell in the session history.
   */
  readonly attribute unsigned long long historyID;

  /**
   * Sets whether a docshell is an app tab. An app tab docshell may behave
   * differently than a non-app tab docshell in some cases, such as when
   * handling link clicks. Docshells are not app tabs unless told otherwise.
   */
  attribute boolean isAppTab;

  /**
   * Create a new about:blank document and content viewer.
   * @param aPrincipal the principal to use for the new document.
   */
  void createAboutBlankContentViewer(in nsIPrincipal aPrincipal);

  /**
   * Upon getting, returns the canonical encoding label of the document
   * currently loaded into this docshell.
   *
   * Upon setting, sets forcedCharset for compatibility with legacy callers.
   */
  attribute ACString charset;

  /**
   * Called when the user chose an encoding override from the character
   * encoding menu. Separate from the setter for the charset property to avoid
   * extensions adding noise to the data.
   */
  void gatherCharsetMenuTelemetry();

  /**
   * The charset forced by the user.
   */
  attribute ACString forcedCharset;

  /**
   * In a child docshell, this is the charset of the parent docshell
   */
  [noscript, notxpcom, nostdcall] void setParentCharset(
    in ACString parentCharset,
    in int32_t parentCharsetSource,
    in nsIPrincipal parentCharsetPrincipal);
  [noscript, notxpcom, nostdcall] void getParentCharset(
    out ACString parentCharset,
    out int32_t parentCharsetSource,
    out nsIPrincipal parentCharsetPrincipal);

  /**
   * Whether the docShell records profile timeline markers at the moment
   */
  [infallible] attribute boolean recordProfileTimelineMarkers;

  /**
   * Return a DOMHighResTimeStamp representing the number of
   * milliseconds from an arbitrary point in time.  The reference
   * point is shared by all DocShells and is also used by timestamps
   * on markers.
   */
  DOMHighResTimeStamp now();

  /**
   * Returns and flushes the profile timeline markers gathered by the docShell
   */
  [implicit_jscontext]
  jsval popProfileTimelineMarkers();

  /**
   * Add an observer to the list of parties to be notified when this docshell's
   * private browsing status is changed. |obs| must support weak references.
   */
  void addWeakPrivacyTransitionObserver(in nsIPrivacyTransitionObserver obs);

  /**
   * Add an observer to the list of parties to be notified when reflows are
   * occurring. |obs| must support weak references.
   */
  void addWeakReflowObserver(in nsIReflowObserver obs);

  /**
   * Remove an observer from the list of parties to be notified about reflows.
   */
  void removeWeakReflowObserver(in nsIReflowObserver obs);

  /**
   * Notify all attached observers that a reflow has just occurred.
   *
   * @param interruptible if true, the reflow was interruptible.
   * @param start         timestamp when reflow started, in milliseconds since
   *                      navigationStart (accurate to 1/1000 of a ms)
   * @param end           timestamp when reflow ended, in milliseconds since
   *                      navigationStart (accurate to 1/1000 of a ms)
   */
  [noscript] void notifyReflowObservers(in bool interruptible,
                                        in DOMHighResTimeStamp start,
                                        in DOMHighResTimeStamp end);

  /**
   * Add an observer to the list of parties to be notified when scroll position
   * of some elements is changed.
   */
  [noscript] void addWeakScrollObserver(in nsIScrollObserver obs);

  /**
   * Add an observer to the list of parties to be notified when scroll position
   * of some elements is changed.
   */
  [noscript] void removeWeakScrollObserver(in nsIScrollObserver obs);

  /**
   * Notify all attached observers that the scroll position of some element
   * has changed.
   */
  [noscript] void notifyScrollObservers();

  /**
   * Returns true iff the docshell corresponds to an <iframe mozapp>.
   */
  [infallible] readonly attribute boolean isApp;

  /**
   * The type of iframe that this docshell lives.
   */
  const unsigned long FRAME_TYPE_REGULAR = 0;
  const unsigned long FRAME_TYPE_BROWSER = 1;
  const unsigned long FRAME_TYPE_APP     = 2;

  [infallible] attribute unsigned long frameType;

  /**
   * Returns true if this docshell corresponds to an <iframe mozbrowser> or
   * <iframe mozapp>.  <xul:browser> returns false here.
   */
  [infallible] readonly attribute boolean isMozBrowserOrApp;

  /**
   * Returns true if this docshell corresponds to an isolated <iframe
   * mozbrowser>.
   *
   * <iframe mozbrowser mozapp> and <xul:browser> are not considered to be
   * mozbrowser elements.  <iframe mozbrowser noisolation> does not count as
   * isolated since isolation is disabled.  Isolation can only be disabled if
   * the containing document is chrome.
   */
  [infallible] readonly attribute boolean isIsolatedMozBrowserElement;

  /**
   * Returns true if this docshell corresponds to an isolated <iframe
   * mozbrowser> or if the docshell is contained in an isolated <iframe
   * mozbrowser>.
   *
   * <iframe mozbrowser mozapp> and <xul:browser> are not considered to be
   * mozbrowser elements.  <iframe mozbrowser noisolation> does not count as
   * isolated since isolation is disabled.  Isolation can only be disabled if
   * the containing document is chrome.
   *
   * Our notion here of "contained in" means: Walk up the docshell hierarchy in
   * this process until we hit an <iframe mozapp> or <iframe mozbrowser> (or
   * until the hierarchy ends).  Return true iff the docshell we stopped on has
   * isIsolatedMozBrowserElement == true.
   */
  [infallible] readonly attribute boolean isInIsolatedMozBrowserElement;

  /**
   * Returns true if this docshell corresponds to an <iframe mozbrowser> or
   * <iframe mozapp>, or if this docshell is contained in an <iframe mozbrowser>
   * or <iframe mozapp>.  <xul:browser> returns false here.
   *
   * To compute this value, we walk up the docshell hierarchy.  If we encounter
   * a docshell with isMozBrowserOrApp before we hit the end of the hierarchy,
   * we return true.  Otherwise, we return false.
   */
  [infallible] readonly attribute boolean isInMozBrowserOrApp;

  /**
   * Returns true if this docshell is the top level content docshell.
   */
  [infallible] readonly attribute boolean isTopLevelContentDocShell;

  /**
   * Returns the id of the app associated with this docshell.  If this docshell
   * is an <iframe mozbrowser> inside an <iframe mozapp>, we return the app's
   * appId.
   *
   * We compute this value by walking up the docshell hierarchy until we find a
   * docshell on which origin attributes was set. (ignoring those docshells
   * where x == UNKNOWN_APP_ID).  We return the app id x.
   *
   * If we don't find a docshell with an associated app id in our hierarchy, we
   * return NO_APP_ID.  We never return UNKNOWN_APP_ID.
   *
   * Notice that a docshell may have an associated app even if it returns true
   * for isBrowserElement!
   */
  [infallible] readonly attribute unsigned long appId;

  /**
   * Return the manifest URL of the app associated with this docshell.
   *
   * If there is no associated app in our hierarchy, we return empty string.
   */
  readonly attribute DOMString appManifestURL;

  /**
   * Like nsIDocShellTreeItem::GetSameTypeParent, except this ignores <iframe
   * mozbrowser> and <iframe mozapp> boundaries.
   */
  nsIDocShell getSameTypeParentIgnoreBrowserAndAppBoundaries();

  /**
   * Like nsIDocShellTreeItem::GetSameTypeRootTreeItem, except this ignores
   * <iframe mozbrowser> and <iframe mozapp> boundaries.
   */
  nsIDocShell getSameTypeRootTreeItemIgnoreBrowserAndAppBoundaries();

  /**
   * True iff asynchronous panning and zooming is enabled for this
   * docshell.
   */
  readonly attribute bool asyncPanZoomEnabled;

  /**
   * The sandbox flags on the docshell. These reflect the value of the sandbox
   * attribute of the associated IFRAME or CSP-protectable content, if
   * existent. See the HTML5 spec for more details.
   * These flags on the docshell reflect the current state of the sandbox
   * attribute, which is modifiable. They are only used when loading new
   * content, sandbox flags are also immutably set on the document when it is
   * loaded.
   * The sandbox flags of a document depend on the sandbox flags on its
   * docshell and of its parent document, if any.
   * See nsSandboxFlags.h for the possible flags.
   */
  attribute unsigned long sandboxFlags;

  /**
   * When a new browsing context is opened by a sandboxed document, it needs to
   * keep track of the browsing context that opened it, so that it can be
   * navigated by it.  This is the "one permitted sandboxed navigator".
   */
  attribute nsIDocShell onePermittedSandboxedNavigator;

  /**
   * Returns true if we are sandboxed from aTargetDocShell.
   * aTargetDocShell - the browsing context we are attempting to navigate.
   */
  [noscript,notxpcom,nostdcall] bool isSandboxedFrom(in nsIDocShell aTargetDocShell);

  /**
   * This member variable determines whether a document has Mixed Active Content that
   * was initially blocked from loading, but the user has choosen to override the
   * block and allow the content to load. mMixedContentChannel is set to the document's
   * channel when the user allows mixed content. The nsMixedContentBlocker content policy
   * checks if the document's root channel matches the mMixedContentChannel.  If it matches,
   * then Mixed Content is loaded.  If it does match, mixed content is blocked.
   *
   * A match implies that there is definitely mixed active content on a page that was
   * initially blocked by nsMixedContentBlocker and then allowed and loaded by the user.
   * A miss imples that IF there is mixed active content on the page AND it was
   * blocked by nsMixedContentBlocker.cpp, the user has not choosen to override
   * the block. Note that if the about:config setting
   * security.mixed_content.block_active_content is set to false, this boolean
   * will be false, mMixedContentChannel will remain null since blocking active content has
   * been disabled and hence mMixedContentChannel will never be set.
   */
  attribute nsIChannel mixedContentChannel;

  /**
   * Checks whether the channel associated with the root docShell is equal to
   * mMixedContentChannel. If they are the same, allowMixedContent is set to true.
   * Checks if the root document has a secure connection. If it is, sets
   * rootHasSecureConnection to true. If the docShell is the root doc shell,
   * isRootDocShell is set to true.
   */
  void GetAllowMixedContentAndConnectionData(out boolean rootHasSecureConnection, out boolean allowMixedContent, out boolean isRootDocShell);


  /**
   * Are plugins allowed in the current document loaded in this docshell ?
   * (if there is one). This depends on whether plugins are allowed by this
   * docshell itself or if the document is sandboxed and hence plugins should
   * not be allowed.
   */
  [noscript, notxpcom] bool pluginsAllowedInCurrentDoc();


  /**
   * Attribute that determines whether fullscreen is allowed to be entered for
   * this subtree of the docshell tree. This is true when all iframes containing
   * this docshell have their "allowfullscreen" attribute set to "true".
   * fullscreenAllowed is only writable at content boundaries, where it is used
   * to propagate the value of the cross process parent's iframe's
   * "allowfullscreen" attribute to the child process. Setting
   * fullscreenAllowed on docshells which aren't content boundaries throws an
   * exception.
   */
  [infallible] readonly attribute boolean fullscreenAllowed;

  void setFullscreenAllowed(in boolean allowed);

  [notxpcom] uint32_t orientationLock();
  [notxpcom] void setOrientationLock(in uint32_t orientationLock);

  [noscript, infallible] attribute boolean affectPrivateSessionLifetime;

  /**
   * Indicates whether the UI may enable the character encoding menu. The UI
   * must disable the menu when this property is false.
   */
  [infallible] readonly attribute boolean mayEnableCharacterEncodingMenu;

           attribute  nsIEditor editor;
  readonly attribute  boolean   editable;             /* this docShell is editable */
  readonly attribute  boolean   hasEditingSession;    /* this docShell has an editing session */

  /**
   * Make this docShell editable, setting a flag that causes
   * an editor to get created, either immediately, or after
   * a url has been loaded.
   *      @param  inWaitForUriLoad    true to wait for a URI before
   *                                  creating the editor.
   */
  void makeEditable(in boolean inWaitForUriLoad);

  /**
   * Get the SHEntry associated with a child docshell
   */
  nsISHEntry getChildSHEntry(in long aChildOffset);

  /**
   * Add a Child SHEntry for a frameset page, given the child's loadtype.
   * If aCloneChildren is true, then aCloneReference's children will be
   * cloned onto aHistoryEntry.
   */
  void addChildSHEntry(in nsISHEntry aCloneReference,
                       in nsISHEntry aHistoryEntry,
                       in long aChildOffset,
                       in unsigned long aLoadType,
                       in boolean aCloneChilden);

  /**
   * Whether this docshell should save entries in global history.
   */
  attribute boolean useGlobalHistory;

  /**
   * Removes nsISHEntry objects related to this docshell from session history.
   * Use this only with subdocuments, like iframes.
   */
  void removeFromSessionHistory();

  /**
   * Set when an iframe/frame is added dynamically.
   */
  attribute boolean createdDynamically;

  /**
   * Returns false for mLSHE, true for mOSHE
   */
  boolean getCurrentSHEntry(out nsISHEntry aEntry);

  /**
    * Cherry picked parts of nsIController.
    * They are here, because we want to call these functions
    * from JS.
    */
  boolean isCommandEnabled(in string command);
  void doCommand(in string command);
  void doCommandWithParams(in string command, in nsICommandParams aParams);

  /**
   * Invisible DocShell are dummy construct to simulate DOM windows
   * without any actual visual representation. They have to be marked
   * at construction time, to avoid any painting activity.
   */
  [noscript, notxpcom] bool IsInvisible();
  [noscript, notxpcom] void SetInvisible(in bool aIsInvisibleDochsell);

/**
 * Get the script global for the document in this docshell.
*/
  [noscript,notxpcom,nostdcall] nsIScriptGlobalObject GetScriptGlobalObject();

  /**
   * If deviceSizeIsPageSize is set to true, device-width/height media queries
   * will be calculated from the page size, not the device size.
   *
   * Used by the Responsive Design Mode and B2G Simulator.
   *
   * Default is False.
   * Default value can be overriden with
   * docshell.device_size_is_page_size pref.
   */
  [infallible] attribute boolean deviceSizeIsPageSize;

  /**
   * Regarding setOpener / getOpener - We can't use XPIDL's "attribute"
   * for notxpcom, so we're relegated to using explicit gets / sets. This
   * should be fine, considering that these methods should only ever be
   * called from native code.
   */
  [noscript,notxpcom,nostdcall] void setOpener(in nsITabParent aOpener);
  [noscript,notxpcom,nostdcall] nsITabParent getOpener();

  /**
   * Notify DocShell when the browser is about to start executing JS, and after
   * that execution has stopped.  This only occurs when the Timeline devtool
   * is collecting information.
   */
  [noscript,notxpcom,nostdcall] void notifyJSRunToCompletionStart(in string aReason,
                                                                  in wstring functionName,
                                                                  in wstring fileName,
                                                                  in unsigned long lineNumber,
                                                                  in jsval asyncStack,
                                                                  in string asyncCause);
  [noscript,notxpcom,nostdcall] void notifyJSRunToCompletionStop();

  /**
   * This attribute determines whether a document which is not about:blank has
   * already be loaded by this docShell.
   */
  [infallible] readonly attribute boolean hasLoadedNonBlankURI;

  /**
   * Allow usage of -moz-window-dragging:drag for content docshells.
   * True for top level chrome docshells. Throws if set to false with
   * top level chrome docshell.
   */
  attribute boolean windowDraggingAllowed;

  /**
   * Sets/gets the current scroll restoration mode.
   * @see https://html.spec.whatwg.org/#dom-history-scroll-restoration
   */
  attribute boolean currentScrollRestorationIsManual;

  /**
   * Setter and getter for the origin attributes living on this docshell.
   */
  [implicit_jscontext]
  jsval getOriginAttributes();

  [implicit_jscontext]
  void setOriginAttributes(in jsval aAttrs);

  /**
   * The editing session for this docshell.
   */
  readonly attribute nsIEditingSession editingSession;

  /**
   * The tab child for this docshell.
   */
  [binaryname(ScriptableTabChild)] readonly attribute nsITabChild tabChild;
  [noscript,notxpcom,nostdcall] TabChildRef GetTabChild();

  [noscript,nostdcall,notxpcom] nsICommandManager GetCommandManager();

  /**
   * This allows chrome to override the default choice of whether touch events
   * are available on a specific docshell. Possible values are listed below.
   */
  attribute unsigned long touchEventsOverride;
  /**
   * Override platform/pref default behaviour and force-disable touch events.
   */
  const unsigned long TOUCHEVENTS_OVERRIDE_DISABLED = 0;
  /**
   * Override platform/pref default behaviour and force-enable touch events.
   */
  const unsigned long TOUCHEVENTS_OVERRIDE_ENABLED = 1;
  /**
   * Don't override the platform/pref default behaviour for touch events.
   */
  const unsigned long TOUCHEVENTS_OVERRIDE_NONE = 2;

  /**
   * A DocShell is locked to the current process if it would be
   * content-observable for a process switch to occur before performing a
   * navigation load. It is important to ensure that a DocShell is not process
   * locked before perfoming process changing loads.
   */
  [infallible] readonly attribute unsigned long processLockReason;
  /**
   * The DocShell is not locked to the current process, and a navigation may
   * proceed in a new process.
   */
  const unsigned long PROCESS_LOCK_NONE = 0;
  /**
   * The DocShell is locked to the current process because it is not a
   * toplevel browsing context.
   */
  const unsigned long PROCESS_LOCK_IFRAME = 1;
  /**
   * The DocShell is locked to the current process because there exist other
   * related browsing contexts which may be holding a reference.
   */
  const unsigned long PROCESS_LOCK_RELATED_CONTEXTS = 2;
  /**
   * The DocShell is locked to the current process because the current
   * process is not a content process.
   *
   * NOTE: Some loads may not consider this a hard process lock, and may wish to
   * ignore this reason.
   */
  const unsigned long PROCESS_LOCK_NON_CONTENT = 3;
};
